#!/command/with-contenv bash

bootstrap_filesystem() {
    if [ ! -d "${CACHE_PATH}" ]; then
        mkdir -p "${CACHE_PATH}"
    fi
    if [ "$(stat -c %U "${CACHE_PATH}")" != "restic" ] ; then chown -R restic:restic "${CACHE_PATH}" ; fi

    if [ ! -d "${CONFIG_PATH}" ]; then
        mkdir -p "${CONFIG_PATH}"
    fi
    if [ "$(stat -c %U "${CONFIG_PATH}")" != "restic" ] ; then chown -R restic:restic "${CONFIG_PATH}" ; fi

    if var_true "${ENABLE_SERVER}" && [ "${SERVER_MODE}" != "rclone" ] ; then
        if [ ! -d "${SERVER_REPOSITORY_PATH}" ]; then
            mkdir -p "${SERVER_REPOSITORY_PATH}"
        fi
        if [ "$(stat -c %U "${SERVER_REPOSITORY_PATH}")" != "restic" ] ; then chown restic:restic "${SERVER_REPOSITORY_PATH}" ; fi
    fi

    if [ -d "${REPOSITORY_PATH}" ]; then
        if [ "$(stat -c %U "${REPOSITORY_PATH}")" != "restic" ] ; then chown restic:restic "${REPOSITORY_PATH}" ; fi
    fi

    if var_true "${ENABLE_HOOKS}" ; then
        if [ ! -d "${HOOKS_PATH}" ]; then
            mkdir -p "${HOOKS_PATH}"
        fi
        if [ "$(stat -c %U "${HOOKS_PATH}")" != "restic" ] ; then chown restic:restic "${HOOKS_PATH}" ; fi

        if [ ! -d "${HOOKS_PRE_PATH}" ]; then
            mkdir -p "${HOOKS_PRE_PATH}"
        fi
        if [ "$(stat -c %U "${HOOKS_PRE_PATH}")" != "restic" ] ; then chown restic:restic "${HOOKS_PRE_PATH}" ; fi
        if [ ! -d "${HOOKS_POST_PATH}" ]; then
            mkdir -p "${HOOKS_POST_PATH}"
        fi
        if [ "$(stat -c %U "${HOOKS_POST_PATH}")" != "restic" ] ; then chown restic:restic "${HOOKS_POST_PATH}" ; fi
    fi

    if [ ! -d "${LOG_PATH}" ]; then
        mkdir -p "${LOG_PATH}"
    fi
    if [ "$(stat -c %U "${LOG_PATH}")" != "restic" ] ; then chown -R restic:restic "${LOG_PATH}" ; fi

    case "${LOG_TYPE,,}" in
        file )
            echo "0 0 * * * /usr/sbin/logrotate_restic >/dev/null 2>&1" > /assets/cron/restic_logrotate

            if var_true "${ENABLE_SERVER}" ; then
                sudo -u restic touch "${SERVER_LOG_PATH}"/"${SERVER_LOG_FILE}"
                chown restic:restic "${SERVER_LOG_PATH}"/"${SERVER_LOG_FILE}"
                create_logrotate restic-rest-server "${SERVER_LOG_PATH}"/"${SERVER_LOG_FILE}" none restic restic
            fi
        ;;
    esac
}

bootstrap_variables() {
    backup_init() {
        backup_instance_number=${1}
        PROCESS_NAME=backup${backup_instance_number}
        backup_instance_vars=$(mktemp)
        set -o posix ; set | grep -oE "^backup_job_.*=" | tr " " "\n" | grep -oE ".*=" | sed "/--/d" > "${backup_instance_vars}"
        while read -r backup_instance_var ; do
            unset "$(echo "${backup_instance_var}" | cut -d = -f 1)"
        done < "${backup_instance_vars}"

        if [ -v "$(echo BACKUP"${backup_instance_number}"_REPOSITORY_PASS)" ] && [ "$(set -o posix; set | grep -E "^BACKUP${backup_instance_number}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
            export RESTIC_PASSWORD="$(set -o posix; set | grep -E "^BACKUP${backup_instance_number}_REPOSITORY_PASS" | cut -d = -f 2)"
        elif [ -n "${DEFAULT_BACKUP_REPOSITORY_PASS}" ] && [ "${DEFAULT_BACKUP_REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD="${DEFAULT_BACKUP_REPOSITORY_PASS}"
        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD="${REPOSITORY_PASS}"
        fi

        if [ -v "$(echo BACKUP${backup_instance_number}_REPOSITORY_PATH)" ] && [ "$(set -o posix; set | grep -E "^BACKUP${backup_instance_number}_REPOSITORY_PATH" | cut -d = -f 2)" != "unset" ]; then
            export backup_job_repository_path="$(set -o posix; set | grep -E "^BACKUP${backup_instance_number}_REPOSITORY_PATH" | cut -d = -f 2)"
        elif [ -n "${DEFAULT_BACKUP_REPOSITORY_PATH}" ] && [ "${DEFAULT_BACKUP_REPOSITORY_PASS}" != "unset" ]; then
            export backup_job_repository_path="${DEFAULT_BACKUP_REPOSITORY_PATH}"
        elif [ -n "${REPOSITORY_PATH}" ] && [ "${REPOSITORY_PATH}" != "unset" ]; then
            export backup_job_repository_path="${REPOSITORY_PATH}"
        fi

        set -o posix ; set | grep -E "^BACKUP${backup_instance_number}_|^DEFAULT_BACKUP_" | tr " " "\n" > "${backup_instance_vars}"

        transform_backup_instance_variable() {
            if grep -q "^BACKUP${1}_${2}=" "${backup_instance_vars}" && [ "$(grep "^BACKUP${1}_${2}=" "${backup_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^BACKUP${1}_${2}=" "${backup_instance_vars}" | cut -d = -f2)"
            elif grep -q "^DEFAULT_BACKUP_${2}=" "${backup_instance_vars}" && [ "$(grep "^DEFAULT_BACKUP_${2}=" "${backup_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^DEFAULT_BACKUP_${2}=" "${backup_instance_vars}" | cut -d = -f2)"
            fi
        }

        transform_backup_instance_variable "${backup_instance_number}" REPOSITORY_PATH backup_job_respository_path
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_ARGS backup_job_backup_args
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_BLACKOUT_BEGIN backup_job_snapshot_blackout_start
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_BLACKOUT_END backup_job_snapshot_blackout_finish
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_DRY_RUN backup_job_snapshot_dryrun
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_EXCLUDE backup_job_snapshot_exclude
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_EXCLUDE_FILE backup_job_snapshot_exclude_file
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_HOOK_POST backup_job_hook_post
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_HOOK_PRE backup_job_hook_pre
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_NAME backup_job_snapshot_name
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_PATH backup_job_snapshot_path
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_PATH_FILE backup_job_snapshot_path_file
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_TAG backup_job_snapshot_tags
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_VERBOSITY_LEVEL backup_job_snapshot_verbosity_level
        rm -rf "${backup_instance_vars}"
    }

    check_init() {
        check_instance_number=${1}
        PROCESS_NAME=check${check_instance_number}
        check_instance_vars=$(mktemp)
        set -o posix ; set | grep -oE "^check_job_.*=" | tr " " "\n" | grep -oE ".*=" | sed "/--/d" > "${check_instance_vars}"
        while read -r check_instance_var ; do
            unset "$(echo "${check_instance_var}" | cut -d = -f 1)"
        done < "${check_instance_vars}"

        set -o posix ; set | grep -E "^CHECK${check_instance_number}_|^DEFAULT_CHECK_" | tr " " "\n" > "${check_instance_vars}"

        if [ -v "$(echo CHECK${check_instance_number}_REPOSITORY_PASS)" ] && [ "$(set -o posix; set | grep -E "^CHECK${check_instance_number}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^CHECK${check_instance_number}_REPOSITORY_PASS" | cut -d = -f 2)
        elif [ -n "${DEFAULT_CHECK_REPOSITORY_PASS}" ] && [ "${DEFAULT_CHECK_REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD=${DEFAULT_CHECK_REPOSITORY_PASS}
        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD=${REPOSITORY_PASS}
        fi

        if [ -v "$(echo CHECK${check_instance_number}_REPOSITORY_PATH)" ] && [ "$(set -o posix; set | grep -E "^CHECK${check_instance_number}_REPOSITORY_PATH" | cut -d = -f 2)" != "unset" ]; then
            export check_job_repository_path="$(set -o posix; set | grep -E "^CHECK${check_instance_number}_REPOSITORY_PATH" | cut -d = -f 2)"
        elif [ -n "${DEFAULT_CHECK_REPOSITORY_PATH}" ] && [ "${DEFAULT_CHECK_REPOSITORY_PASS}" != "unset" ]; then
            export check_job_repository_path="${DEFAULT_CHECK_REPOSITORY_PATH}"
        elif [ -n "${REPOSITORY_PATH}" ] && [ "${REPOSITORY_PATH}" != "unset" ]; then
            export check_job_repository_path="${REPOSITORY_PATH}"
        fi

        transform_check_instance_variable() {
            if grep -q "^CHECK${1}_${2}=" "${check_instance_vars}" && [ "$(grep "^CHECK${1}_${2}=" "${check_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^CHECK${1}_${2}=" "${check_instance_vars}" | cut -d = -f2)"
            elif grep -q "^DEFAULT_CHECK_${2}=" "${check_instance_vars}" && [ "$(grep "^DEFAULT_CHECK_${2}=" "${check_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^DEFAULT_CHECK_${2}=" "${check_instance_vars}" | cut -d = -f2)"
            fi
        }

        transform_check_instance_variable "${check_instance_number}" ARGS check_job_check_args
        transform_check_instance_variable "${check_instance_number}" BLACKOUT_BEGIN check_job_blackout_start
        transform_check_instance_variable "${check_instance_number}" BLACKOUT_END check_job_blackout_finish
        transform_check_instance_variable "${check_instance_number}" CHECK_AMOUNT check_job_check_amount
        transform_check_instance_variable "${check_instance_number}" DRY_RUN check_job_check_dryrun
        transform_check_instance_variable "${check_instance_number}" HOOK_POST check_job_check_hook_post
        transform_check_instance_variable "${check_instance_number}" HOOK_PRE check_job_check_hook_pre
        transform_check_instance_variable "${check_instance_number}" NAME check_job_check_name
        transform_check_instance_variable "${check_instance_number}" REPOSITORY_PASS check_job_repository_pass
        transform_check_instance_variable "${check_instance_number}" REPOSITORY_PATH check_job_repository_path
        transform_check_instance_variable "${check_instance_number}" USE_CACHE check_job_check_use_cache
        transform_check_instance_variable "${check_instance_number}" VERBOSITY_LEVEL check_job_verbosity_level
        rm -rf "${check_instance_vars}"
    }

    cleanup_init() {
        cleanup_instance_number=${1}
        PROCESS_NAME=cleanup${cleanup_instance_number}
        cleanup_instance_vars=$(mktemp)
        set -o posix ; set | grep -oE "^cleanup_job_.*=" | tr " " "\n" | grep -oE ".*=" | sed "/--/d" > "${cleanup_instance_vars}"
        while read -r cleanup_instance_var ; do
            unset "$(echo "${cleanup_instance_var}" | cut -d = -f 1)"
        done < "${cleanup_instance_vars}"

        set -o posix ; set | grep -E "^CLEANUP${cleanup_instance_number}_|^DEFAULT_CLEANUP_" | tr " " "\n" > "${cleanup_instance_vars}"

        if [ -v "$(echo CLEANUP${cleanup_instance_number}_REPOSITORY_PASS)" ] && [ "$(set -o posix; set | grep -E "^CLEANUP${cleanup_instance_number}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^CLEANUP${cleanup_instance_number}_REPOSITORY_PASS" | cut -d = -f 2)
        elif [ -n "${DEFAULT_CLEANUP_REPOSITORY_PASS}" ] && [ "${DEFAULT_CLEANUP_REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD=${DEFAULT_CLEANUP_REPOSITORY_PASS}
        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD=${REPOSITORY_PASS}
        fi

        if [ -v "$(echo CLEANUP${cleanup_instance_number}_REPOSITORY_PATH)" ] && [ "$(set -o posix; set | grep -E "^CLEANUP${cleanup_instance_number}_REPOSITORY_PATH" | cut -d = -f 2)" != "unset" ]; then
            export cleanup_job_repository_path="$(set -o posix; set | grep -E "^CLEANUP${cleanup_instance_number}_REPOSITORY_PATH" | cut -d = -f 2)"
        elif [ -n "${DEFAULT_CLEANUP_REPOSITORY_PATH}" ] && [ "${DEFAULT_CLEANUP_REPOSITORY_PASS}" != "unset" ]; then
            export cleanup_job_repository_path="${DEFAULT_CLEANUP_REPOSITORY_PATH}"
        elif [ -n "${REPOSITORY_PATH}" ] && [ "${REPOSITORY_PATH}" != "unset" ]; then
            export cleanup_job_repository_path="${REPOSITORY_PATH}"
        fi

        transform_cleanup_instance_variable() {
            if grep -q "^CLEANUP${1}_${2}=" "${cleanup_instance_vars}" && [ "$(grep "^CLEANUP${1}_${2}=" "${cleanup_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^CLEANUP${1}_${2}=" "${cleanup_instance_vars}" | cut -d = -f2)"
            elif grep -q "^DEFAULT_CLEANUP_${2}=" "${cleanup_instance_vars}" && [ "$(grep "^DEFAULT_CLEANUP_${2}=" "${cleanup_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^DEFAULT_CLEANUP_${2}=" "${cleanup_instance_vars}" | cut -d = -f2)"
            fi
        }

        transform_cleanup_instance_variable "${cleanup_instance_number}" AUTO_PRUNE cleanup_job_auto_prune
        transform_cleanup_instance_variable "${cleanup_instance_number}" ARGS cleanup_job_cleanup_args
        transform_cleanup_instance_variable "${cleanup_instance_number}" BLACKOUT_BEGIN cleanup_job_blackout_start
        transform_cleanup_instance_variable "${cleanup_instance_number}" BLACKOUT_END cleanup_job_blackout_finish
        transform_cleanup_instance_variable "${cleanup_instance_number}" DRY_RUN cleanup_job_cleanup_dryrun
        transform_cleanup_instance_variable "${cleanup_instance_number}" HOOK_POST cleanup_job_cleanup_hook_post
        transform_cleanup_instance_variable "${cleanup_instance_number}" HOOK_PRE cleanup_job_cleanup_hook_pre
        transform_cleanup_instance_variable "${cleanup_instance_number}" NAME cleanup_job_cleanup_name
        transform_cleanup_instance_variable "${cleanup_instance_number}" REPACK cleanup_job_cleanup_repack
        transform_cleanup_instance_variable "${cleanup_instance_number}" REPOSITORY_PASS cleanup_job_repository_pass
        transform_cleanup_instance_variable "${cleanup_instance_number}" REPOSITORY_PATH cleanup_job_repository_path
        transform_cleanup_instance_variable "${cleanup_instance_number}" RETAIN_LAST cleanup_job_retain_last
        transform_cleanup_instance_variable "${cleanup_instance_number}" RETAIN_HOURLY cleanup_job_retain_hourly
        transform_cleanup_instance_variable "${cleanup_instance_number}" RETAIN_DAILY cleanup_job_retain_daily
        transform_cleanup_instance_variable "${cleanup_instance_number}" RETAIN_WEEKLY cleanup_job_retain_weekly
        transform_cleanup_instance_variable "${cleanup_instance_number}" RETAIN_MONTHLY cleanup_job_retain_monthly
        transform_cleanup_instance_variable "${cleanup_instance_number}" RETAIN_YEARLY cleanup_job_retain_yearly
        transform_cleanup_instance_variable "${cleanup_instance_number}" RETAIN_TAGS cleanup_job_retain_tag
        transform_cleanup_instance_variable "${cleanup_instance_number}" SHOW_INVENTORY cleanup_job_show_inventory
        transform_cleanup_instance_variable "${cleanup_instance_number}" VERBOSITY_LEVEL cleanup_job_cleanup_verbosity_level
        rm -rf "${cleanup_instance_vars}"
    }

    inventory_init() {
        inventory_instance_number=${1}
        PROCESS_NAME=inventory${inventory_instance_number}
        inventory_instance_vars=$(mktemp)
        set -o posix ; set | grep -oE "^inventory_job_.*=" | tr " " "\n" | grep -oE ".*=" | sed "/--/d" > "${inventory_instance_vars}"
        while read -r inventory_instance_var ; do
            unset "$(echo "${inventory_instance_var}" | cut -d = -f 1)"
        done < "${inventory_instance_vars}"

        if [ -v $(echo INVENTORY"${inventory_instance_number}"_REPOSITORY_PASS) ] && [ "$(set -o posix; set | grep -E "^INVENTORY${inventory_instance_number}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^INVENTORY"${inventory_instance_number}"_REPOSITORY_PASS" | cut -d = -f 2)
        elif [ -n "${DEFAULT_INVENTORY_REPOSITORY_PASS}" ] && [ "${DEFAULT_INVENTORY_REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD=${DEFAULT_INVENTORY_REPOSITORY_PASS}
        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD=${REPOSITORY_PASS}
        fi

        if [ -v "$(echo INVENTORY${inventory_instance_number}_REPOSITORY_PATH)" ] && [ "$(set -o posix; set | grep -E "^INVENTORY${inventory_instance_number}_REPOSITORY_PATH" | cut -d = -f 2)" != "unset" ]; then
            export inventory_job_repository_path="$(set -o posix; set | grep -E "^INVENTORY${inventory_instance_number}_REPOSITORY_PATH" | cut -d = -f 2)"
        elif [ -n "${DEFAULT_INVENTORY_REPOSITORY_PATH}" ] && [ "${DEFAULT_INVENTORY_REPOSITORY_PASS}" != "unset" ]; then
            export inventory_job_repository_path="${DEFAULT_INVENTORY_REPOSITORY_PATH}"
        elif [ -n "${REPOSITORY_PATH}" ] && [ "${REPOSITORY_PATH}" != "unset" ]; then
            export inventory_job_repository_path="${REPOSITORY_PATH}"
        fi

        set -o posix ; set | grep -E "^INVENTORY${inventory_instance_number}_|^DEFAULT_INVENTORY_" | tr " " "\n" > "${inventory_instance_vars}"

        transform_inventory_instance_variable() {
            if grep -q "^INVENTORY${1}_${2}=" "${inventory_instance_vars}" && [ "$(grep "^INVENTORY${1}_${2}=" "${inventory_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^INVENTORY${1}_${2}=" "${inventory_instance_vars}" | cut -d = -f2)"
            elif grep -q "^DEFAULT_INVENTORY_${2}=" "${inventory_instance_vars}" && [ "$(grep "^DEFAULT_INVENTORY_${2}=" "${inventory_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^DEFAULT_INVENTORY_${2}=" "${inventory_instance_vars}" | cut -d = -f2)"
            fi
        }
        transform_inventory_instance_variable "${inventory_instance_number}" NAME inventory_job_inventory_name
        transform_inventory_instance_variable "${inventory_instance_number}" HOOK_POST inventory_job_hook_post
        transform_inventory_instance_variable "${inventory_instance_number}" HOOK_PRE inventory_job_hook_pre
        transform_inventory_instance_variable "${inventory_instance_number}" REPOSITORY_PASS inventory_job_repository_pass
        transform_inventory_instance_variable "${inventory_instance_number}" REPOSITORY_PATH inventory_job_repository_path
        rm -rf "${inventory_instance_vars}"
    }

    prune_init() {
        prune_instance_number=${1}
        PROCESS_NAME=prune${prune_instance_number}
        prune_instance_vars=$(mktemp)
        set -o posix ; set | grep -oE "^prune_job_.*=" | tr " " "\n" | grep -oE ".*=" | sed "/--/d" > "${prune_instance_vars}"
        while read -r prune_instance_var ; do
            unset "$(echo "${prune_instance_var}" | cut -d = -f 1)"
        done < "${prune_instance_vars}"

        if [ -v $(echo PRUNE"${prune_instance_number}"_REPOSITORY_PASS) ] && [ "$(set -o posix; set | grep -E "^PRUNE${prune_instance_number}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^PRUNE"${prune_instance_number}"_REPOSITORY_PASS" | cut -d = -f 2)
        elif [ -n "${DEFAULT_PRUNE_REPOSITORY_PASS}" ] && [ "${DEFAULT_PRUNE_REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD=${DEFAULT_PRUNE_REPOSITORY_PASS}
        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD=${REPOSITORY_PASS}
        fi

        if [ -v "$(echo PRUNE${prune_instance_number}_REPOSITORY_PATH)" ] && [ "$(set -o posix; set | grep -E "^PRUNE${prune_instance_number}_REPOSITORY_PATH" | cut -d = -f 2)" != "unset" ]; then
            export prune_job_repository_path="$(set -o posix; set | grep -E "^PRUNE${prune_instance_number}_REPOSITORY_PATH" | cut -d = -f 2)"
        elif [ -n "${DEFAULT_PRUNE_REPOSITORY_PATH}" ] && [ "${DEFAULT_PRUNE_REPOSITORY_PASS}" != "unset" ]; then
            export prune_job_repository_path="${DEFAULT_PRUNE_REPOSITORY_PATH}"
        elif [ -n "${REPOSITORY_PATH}" ] && [ "${REPOSITORY_PATH}" != "unset" ]; then
            export prune_job_repository_path="${REPOSITORY_PATH}"
        fi

        set -o posix ; set | grep -E "^PRUNE${prune_instance_number}_|^DEFAULT_PRUNE_" | tr " " "\n" > "${prune_instance_vars}"

        transform_prune_instance_variable() {
            if grep -q "^PRUNE${1}_${2}=" "${prune_instance_vars}" && [ "$(grep "^PRUNE${1}_${2}=" "${prune_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^PRUNE${1}_${2}=" "${prune_instance_vars}" | cut -d = -f2)"
            elif grep -q "^DEFAULT_PRUNE_${2}=" "${prune_instance_vars}" && [ "$(grep "^DEFAULT_PRUNE_${2}=" "${prune_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^DEFAULT_PRUNE_${2}=" "${prune_instance_vars}" | cut -d = -f2)"
            fi
        }

        transform_prune_instance_variable "${prune_instance_number}" ARGS prune_job_prune_args
        transform_prune_instance_variable "${prune_instance_number}" BLACKOUT_BEGIN prune_job_blackout_start
        transform_prune_instance_variable "${prune_instance_number}" BLACKOUT_END prune_job_blackout_finish
        transform_prune_instance_variable "${prune_instance_number}" DRY_RUN prune_job_prune_dryrun
        transform_prune_instance_variable "${prune_instance_number}" HOOK_POST prune_job_prune_hook_post
        transform_prune_instance_variable "${prune_instance_number}" HOOK_PRE prune_job_prune_hook_pre
        transform_prune_instance_variable "${prune_instance_number}" NAME prune_job_prune_name
        transform_prune_instance_variable "${prune_instance_number}" REPOSITORY_PASS prune_job_repository_pass
        transform_prune_instance_variable "${prune_instance_number}" REPOSITORY_PATH prune_job_repository_path
        transform_prune_instance_variable "${prune_instance_number}" VERBOSITY_LEVEL prune_job_verbosity_level
        rm -rf "${prune_instance_vars}"
    }

    unlock_init() {
        unlock_called_from=${1}
        unlock_called_from_instance=${2}
        PROCESS_NAME=unlock
        unlock_instance_vars=$(mktemp)
        set -o posix ; set | grep -oE "^unlock_job_.*=" | tr " " "\n" | grep -oE ".*=" | sed "/--/d" > "${unlock_instance_vars}"
        while read -r unlock_instance_var ; do
            unset "$(echo "${unlock_instance_var}" | cut -d = -f 1)"
        done < "${unlock_instance_vars}"

        if [ -v "$(echo ${unlock_called_from}${unlock_called_from_instance}_REPOSITORY_PASS)" ] && [ "$(set -o posix; set | grep -E "^${unlock_called_from}${unlock_called_from_instance}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^${unlock_called_from}${unlock_called_from_instance}_REPOSITORY_PASS" | cut -d = -f 2)
        elif [ -v "$(echo DEFAULT_"${unlock_called_from}"_REPOSITORY_PASS)" ] && [ "$(grep -E "^$(echo DEFAULT_${unlock_called_from}_REPOSITORY_PASS)" | cut -d = -f 2)" != "unset" ] ; then
            export RESTIC_PASSWORD="$(grep -E "^$(echo DEFAULT_"${unlock_called_from}"_REPOSITORY_PASS)" | cut -d = -f 2)"
        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD="${REPOSITORY_PASS}"
        fi

        if [ -v "$(echo "${unlock_called_from}""${unlock_called_from_instance}"_REPOSITORY_PATH)" ] && [ "$(set -o posix; set | grep -E "^${unlock_called_from}${unlock_called_from_instance}_REPOSITORY_PATH" | cut -d = -f 2)" != "unset" ]; then
            export unlock_job_repository_path="$(set -o posix; set | grep -E "^${unlock_called_from}${unlock_called_from_instance}_REPOSITORY_PATH" | cut -d = -f 2)"
        elif [ -v "$(echo DEFAULT_${unlock_called_from}_REPOSITORY_PATH)" ] && [ "$(grep -E "^$(echo DEFAULT_${unlock_called_from}_REPOSITORY_PATH)" | cut -d = -f 2)" != "unset" ] ; then
            export unlock_job_repository_path="$(grep -E "^$(echo DEFAULT_${unlock_called_from}_REPOSITORY_PATH)" | cut -d = -f 2)"
        elif [ -n "${REPOSITORY_PATH}" ] && [ "${REPOSITORY_PATH}" != "unset" ]; then
            export unlock_job_repository_path=${REPOSITORY_PATH}
        fi

        set -o posix ; set | grep -E "^UNLOCK_|^DEFAULT_UNLOCK_" | tr " " "\n" > "${unlock_instance_vars}"

        transform_unlock_variable() {
            if grep -q "^UNLOCK_${1}=" "${unlock_instance_vars}" && [ "$(grep "^UNLOCK_${1}=" "${unlock_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$2"="$(grep "^UNLOCK_${1}=" "${unlock_instance_vars}" | cut -d = -f2)"
            elif grep -q "^DEFAULT_UNLOCK_${1}=" "${unlock_instance_vars}" && [ "$(grep "^DEFAULT_UNLOCK_${1}=" "${unlock_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$2"="$(grep "^DEFAULT_UNLOCK_${1}=" "${unlock_instance_vars}" | cut -d = -f2)"
            fi
        }

        transform_unlock_variable ARGS unlock_job_unlock_args
        transform_unlock_variable HOOK_POST unlock_job_hook_post
        transform_unlock_variable HOOK_PRE unlock_job_hook_pre
        transform_unlock_variable REMOVE_ALL unlock_job_remove_all
        transform_unlock_variable VERBOSITY_LEVEL unlock_job_verbosity_level

        rm -rf "${unlock_instance_vars}"
    }

    upgrade_lonely_variables() {
        upgrade_lonely_variables_tmp=$(mktemp)
        set -o posix; set | grep "^$1" | grep -v "^$1[0-9]._" > "${upgrade_lonely_variables_tmp}"
        while read -r exist_var ; do
            if [ ! -v "${1}"01_"$(echo "${exist_var}" | cut -d = -f1 | cut -d _ -f2)" ] ; then
                export "${1}"01_"$(echo "${exist_var}" | cut -d = -f1 | cut -d _ -f2-9)"="$(echo "${exist_var}" | cut -d = -f2)"
            else
                print_error "Variable ${1}01_$(echo "${exist_var}" | cut -d = -f1 | cut -d _ -f2) already exists, fix your variables and start again.."
                exit 1
            fi
        done < "${upgrade_lonely_variables_tmp}"
        rm -rf "${upgrade_lonely_variables_tmp}"
    }

    case "${1}" in
        backup_init ) backup_init "$2" ;;
        check_init ) check_init "$2" ;;
        cleanup_init ) cleanup_init "$2" ;;
        inventory_init ) inventory_init "$2" ;;
        prune_init ) prune_init "$2" ;;
        unlock_init ) unlock_init "$2" "$3" ;;
        upgrade ) upgrade_lonely_variables "$2" ;;
    esac
}


create_schedulers() {
    backup() {
        bootstrap_variables upgrade BACKUP
        local backup_instances=$(printenv | sort | grep -c "^BACKUP[0-9]._SNAPSHOT_PATH")
        for (( instance = 01; instance <= backup_instances; instance++ )) ; do
            instance=$(printf "%02d" $instance)
            if [ -v BACKUP${instance}_REPOSITORY_PATH ] && [ "$(set -o posix; set | grep -E "^BACKUP${instance}_REPOSITORY_PATH" | cut -d = -f 2)" != "unset" ]; then
                echo "BACKUP${instance} $(grep -E "^BACKUP${instance}_REPOSITORY_PATH" | cut -d = -f 2)" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            elif [ -n "${DEFAULT_BACKUP_REPOSITORY_PATH}" ] && [ "${DEFAULT_BACKUP_REPOSITORY_PATH}" != "unset" ]; then
                echo "BACKUP${instance} ${DEFAULT_BACKUP_REPOSITORY_PATH}" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            elif [ -n "${REPOSITORY_PATH}" ] && [ "${REPOSITORY_PATH}" != "unset" ]; then
                echo "BACKUP${instance} ${REPOSITORY_PATH}" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            fi

            cp -R /assets/restic/template-restic-backup /etc/services.available/restic-backup"${instance}"
            sed -i "s|{{BACKUP_NUMBER}}|${instance}|g" /etc/services.available/restic-backup"${instance}"/run
            cat <<EOF >> /usr/bin/backup"${instance}"-now
#!/bin/bash
source /assets/functions/00-container
PROCESS_NAME=backup${instance}
print_info "Starting Manual Backup for BACKUP${instance}"
/var/run/s6/legacy-services/restic-backup${instance}/run now

EOF
            chmod +x /usr/bin/backup"${instance}"-now
            if [ "${instance}" = "01" ] ; then
                touch /usr/bin/backup-now
                chmod +x /usr/bin/backup-now
                cat <<EOF > /usr/bin/backup-now
#!/bin/bash

/usr/bin/backup${instance}-now

EOF
            else
                echo "/usr/bin/backup${instance}-now" >> /usr/bin/backup-now
            fi
        done
    }

    check() {
        bootstrap_variables upgrade CHECK
        check_instances=$(set -o posix ; set | sort | grep -E "^CHECK[0-9]._" | cut -d _ -f1 | uniq | wc -l)
        for (( instance = 01; instance <= check_instances; instance++ )) ; do
            instance=$(printf "%02d" $instance)

            if [ -v CHECK${instance}_REPOSITORY_PATH ] && [ "$(set -o posix; set | grep -E "^CHECK${instance}_REPOSITORY_PATH" | cut -d = -f 2)" != "unset" ]; then
                echo "CHECK${instance} $(set -o posix; set | grep -E "^CHECK${instance}_REPOSITORY_PATH" | cut -d = -f 2)" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            elif [ -n "${DEFAULT_CHECK_REPOSITORY_PATH}" ] && [ "${DEFAULT_CHECK_REPOSITORY_PATH}" != "unset" ]; then
                echo "CHECK${instance} ${DEFAULT_CHECK_REPOSITORY_PATH}" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            elif [ -n "${REPOSITORY_PATH}" ] && [ "${REPOSITORY_PATH}" != "unset" ]; then
                echo "CHECK${instance} ${REPOSITORY_PATH}" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            fi
            cp -R /assets/restic/template-restic-check /etc/services.available/restic-check"${instance}"
            sed -i "s|{{CHECK_NUMBER}}|${instance}|g" /etc/services.available/restic-check"${instance}"/run

        cat <<EOF >> /usr/bin/check"${instance}"-now
#!/bin/bash
source /assets/functions/00-container
PROCESS_NAME=check${instance}
print_info "Starting Manual Check for for CHECK${instance}"
/var/run/s6/legacy-services/restic-check${instance}/run now

EOF
            chmod +x /usr/bin/check"${instance}"-now
            if [ "${instance}" = "01" ] ; then
                touch /usr/bin/check-now
                chmod +x /usr/bin/check-now
                cat <<EOF > /usr/bin/check-now
#!/bin/bash

/usr/bin/check${instance}-now

EOF
            else
                echo "/usr/bin/check${instance}-now" >> /usr/bin/check-now
            fi
        done
    }

    cleanup() {
        bootstrap_variables upgrade CLEANUP
        cleanup_instances=$(set -o posix ; set | sort | grep -E "^CLEANUP[0-9]._" | cut -d _ -f1 | uniq | wc -l)
        for (( instance = 01; instance <= cleanup_instances; instance++ )) ; do
            instance=$(printf "%02d" $instance)

            if [ -v CLEANUP${instance}_REPOSITORY_PATH ] && [ "$(set -o posix; set | grep -E "^CLEANUP${instance}_REPOSITORY_PATH" | cut -d = -f 2)" != "unset" ]; then
                echo "CLEANUP${instance} $(set -o posix; set | grep -E "^CLEANUP${instance}_REPOSITORY_PATH" | cut -d = -f 2)" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            elif [ -n "${DEFAULT_CLEANUP_REPOSITORY_PATH}" ] && [ "${DEFAULT_CLEANUP_REPOSITORY_PATH}" != "unset" ]; then
                echo "CLEANUP${instance} ${DEFAULT_CLEANUP_REPOSITORY_PATH}" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            elif [ -n "${REPOSITORY_PATH}" ] && [ "${REPOSITORY_PATH}" != "unset" ]; then
                echo "CLEANUP${instance} ${REPOSITORY_PATH}" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            fi

            cp -R /assets/restic/template-restic-cleanup /etc/services.available/restic-cleanup"${instance}"
            sed -i "s|{{CLEANUP_NUMBER}}|${instance}|g" /etc/services.available/restic-cleanup"${instance}"/run

        cat <<EOF >> /usr/bin/cleanup"${instance}"-now
#!/bin/bash
source /assets/functions/00-container
PROCESS_NAME=cleanup${instance}
print_info "Starting Manual Check for for CLEANUP${instance}"
/var/run/s6/legacy-services/restic-cleanup${instance}/run now

EOF
            chmod +x /usr/bin/cleanup"${instance}"-now
            if [ "${instance}" = "01" ] ; then
                touch /usr/bin/cleanup-now
                chmod +x /usr/bin/cleanup-now
                cat <<EOF > /usr/bin/cleanup-now
#!/bin/bash

/usr/bin/cleanup${instance}-now

EOF
            else
                echo "/usr/bin/cleanup${instance}-now" >> /usr/bin/cleanup-now
            fi
        done
    }

    init() {
        if [ -f "/tmp/.container/toi_restic/INIT_REPOSITORIES" ]; then
            print_debug "Creating init repositories routine"
            touch /tmp/.container/toi_restic/INIT_REPOSITORIES
            sort -t ' ' -k2 -u /tmp/.container/toi_restic/INIT_REPOSITORIES -o /tmp/.container/toi_restic/INIT_REPOSITORIES
        fi

        cp -R /assets/restic/template-restic-initialize_repository /etc/services.available/restic-initialize_repository
    }

    inventory() {
        bootstrap_variables upgrade INVENTORY
        inventory_instances=$(set -o posix ; set | sort | grep -E "^INVENTORY[0-9]._" | cut -d _ -f1 | uniq | wc -l)
        for (( instance = 01; instance <= inventory_instances; instance++ )) ; do
            instance=$(printf "%02d" $instance)

            if [ -v INVENTORY${instance}_REPOSITORY_PATH ] && [ "$(set -o posix; set | grep -E "^INVENTORY${instance}_REPOSITORY_PATH" | cut -d = -f 2)" != "unset" ]; then
                echo "INVENTORY${instance} $(set -o posix; set | grep -E "^INVENTORY${instance}_REPOSITORY_PATH" | cut -d = -f 2)" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            elif [ -n "${DEFAULT_INVENTORY_REPOSITORY_PATH}" ] && [ "${DEFAULT_INVENTORY_REPOSITORY_PATH}" != "unset" ]; then
                echo "INVENTORY${instance} ${DEFAULT_INVENTORY_REPOSITORY_PATH}" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            elif [ -n "${REPOSITORY_PATH}" ] && [ "${REPOSITORY_PATH}" != "unset" ]; then
                echo "INVENTORY${instance} ${REPOSITORY_PATH}" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            fi

            cp -R /assets/restic/template-restic-inventory /etc/services.available/restic-inventory"${instance}"
            sed -i "s|{{INVENTORY_NUMBER}}|${instance}|g" /etc/services.available/restic-inventory"${instance}"/run

        cat <<EOF >> /usr/bin/inventory"${instance}"-now
#!/bin/bash
source /assets/functions/00-container
PROCESS_NAME=inventory${instance}
print_info "Starting Manual Inventory for for INVENTORY${instance}"
/var/run/s6/legacy-services/restic-inventory${instance}/run now

EOF
            chmod +x /usr/bin/inventory"${instance}"-now
            if [ "${instance}" = "01" ] ; then
                touch /usr/bin/inventory-now
                chmod +x /usr/bin/inventory-now
                cat <<EOF > /usr/bin/inventory-now
#!/bin/bash

/usr/bin/inventory${instance}-now

EOF
            else
                echo "/usr/bin/inventory${instance}-now" >> /usr/bin/inventory-now
            fi
        done
    }

    prune() {
        bootstrap_variables upgrade PRUNE
        local prune_instances=$(set -o posix ; set | sort | grep -E "^PRUNE[0-9]._" | cut -d _ -f1 | uniq | wc -l)
        for (( instance = 01; instance <= prune_instances; instance++ )) ; do
            instance=$(printf "%02d" $instance)

            if [ -v PRUNE${instance}_REPOSITORY_PATH ] && [ "$(set -o posix; set | grep -E "^PRUNE${instance}_REPOSITORY_PATH" | cut -d = -f 2)" != "unset" ]; then
                echo "PRUNE${instance} $(set -o posix; set | grep -E "^PRUNE${instance}_REPOSITORY_PATH" | cut -d = -f 2)" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            elif [ -n "${DEFAULT_PRUNE_REPOSITORY_PATH}" ] && [ "${DEFAULT_PRUNE_REPOSITORY_PATH}" != "unset" ]; then
                echo "PRUNE${instance} ${DEFAULT_PRUNE_REPOSITORY_PATH}" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            elif [ -n "${REPOSITORY_PATH}" ] && [ "${REPOSITORY_PATH}" != "unset" ]; then
                echo "PRUNE${instance} ${REPOSITORY_PATH}" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            fi

            cp -R /assets/restic/template-restic-prune /etc/services.available/restic-prune"${instance}"
            sed -i "s|{{PRUNE_NUMBER}}|${instance}|g" /etc/services.available/restic-prune"${instance}"/run

            cat <<EOF >> /usr/bin/prune"${instance}"-now
#!/bin/bash
source /assets/functions/00-container
PROCESS_NAME=prune${instance}
print_info "Starting Manual Prune for PRUNE${instance}"
/var/run/s6/legacy-services/restic-prune${instance}/run now

EOF
            chmod +x /usr/bin/prune"${instance}"-now
            if [ "${instance}" = "01" ] ; then
                touch /usr/bin/prune-now
                chmod +x /usr/bin/prune-now
                cat <<EOF > /usr/bin/prune-now
#!/bin/bash

/usr/bin/prune${instance}-now

EOF
            else
                echo "/usr/bin/prune${instance}-now" >> /usr/bin/prune-now
            fi
        done
    }

    case "${1}" in
        backup ) backup ;;
        check ) check ;;
        cleanup) cleanup ;;
        init ) init ;;
        inventory ) inventory ;;
        prune ) prune ;;
    esac
}

hooks() {
    post() {
        case "${1}" in
            backup )
                if [ -x "${backup_job_hook_post}" ] ; then
                    print_notice "Executing post snapshot custom script : '${backup_job_hook_post}'"
                    ## script HOSTNAME CONTAINER_NAME BACKUP INSTANCE_NUMBER[XX] BACKUP[XX]NAME BACKUP[XX]REPOSITORY_PATH ROUTINE_START_EPOCH PROCESS_START_EPOCH PROCESS_FINISH_EPOCH PROCESS_TOTAL_EPOCH EXITCODE LOGFILE FILES_NEW FILES_CHANGED FILES_UNMODIFIED DIRS_NEW DIRS_CHANGED DIRS_UNMODIFIED SIZE_BYTES_ADDED SIZE_BYTES_STORED SIZE_BYTES_PROCESSED ERROR_COUNT
                    "${backup_job_hook_post}" "$(hostname)" "${CONTAINER_NAME}" BACKUP "${backup_instance_number}" "${backup_job_log_suffix}" "${backup_job_repository_path}" "${backup_routines_start_time}" "${backup_process_start_time}" "${backup_process_finish_time}" "${backup_process_total_time}" "${exitcode_backup}" "${LOG_PATH}"/"$(date +'%Y%m%d')"/"$(date -d @"${backup_process_start_time}" +'%Y%m%d_%H%M%S')"-backup-"${backup_job_log_suffix}".log "${backup_job_backup_summary_files_new}" "${backup_job_backup_summary_files_changed}" "${backup_job_backup_summary_files_unmodified}" "${backup_job_backup_summary_directory_new}" "${backup_job_backup_summary_directory_changed}" "${backup_job_backup_summary_directory_unmodified}" "${backup_job_backup_summary_added_size_bytes}" "${backup_job_backup_summary_added_size_stored_bytes}" "${backup_job_backup_summary_processed_size_bytes}" "${backup_job_backup_summary_error_count}"
                else
                    print_error "Can't run post snapshot custom script: '${backup_job_hook_post}' as its filesystem bit is not executible!"
                fi
            ;;
            check )
                if [ -x "${check_job_hook_post}" ] ; then
                    print_notice "Executing post check custom script : '${check_job_hook_post}'"
                    ## script HOSTNAME CONTAINER_NAME TYPE INSTANCE_NUMBER NAME REPOSITORY_PATH ROUTINE_START_EPOCH PROCESS_START_EPOCH PROCESS_FINISH_EPOCH PROCESS_TOTAL_SECONDS EXITCODE LOGFILE PACKS_UNREFERENCED_COUNT SNAPSHOTS_PROCESSED
                    "${check_job_hook_post}" "$(hostname)" "${CONTAINER_NAME}" CHECK "${check_instance_number}" "${check_job_log_suffix}" "${check_job_repository_path}" "${check_routines_start_time}" "${check_process_start_time}" "${check_process_finish_time}" "${check_process_total_time}" "${exitcode_check}" "${LOG_PATH}"/"$(date +'%Y%m%d')"/"$(date -d @"${check_process_start_time}" +'%Y%m%d_%H%M%S')"-check-"${check_job_log_suffix}".log "${check_job_pack_unreferenced_count}" "${check_job_snapshots_processed}"
                else
                    print_error "Can't run post check custom script: '${check_job_hook_post}' as its filesystem bit is not executible!"
                fi
            ;;
            cleanup )
                if [ -x "${cleanup_job_hook_post}" ] ; then
                    print_notice "Executing post cleanup custom script : '${cleanup_job_hook_post}'"
                    ## script HOSTNAME CONTAINER_NAME TYPE INSTANCE_NUMBER NAME REPOSITORY_PATH ROUTINE_START_EPOCH PROCESS_START_EPOCH PROCESS_FINISH_EPOCH PROCESS_TOTAL_SECONDS EXITCODE LOGFILE
                    "${cleanup_job_hook_post}" "$(hostname)" "${CONTAINER_NAME}" CLEANUP "${cleanup_instance_number}" "${cleanup_job_log_suffix}" "${cleanup_job_repository_path}" "${cleanup_routines_start_time}" "${cleanup_process_start_time}" "${cleanup_process_finish_time}" "${cleanup_process_total_time}" "${exitcode_cleanup}" "${LOG_PATH}"/"$(date +'%Y%m%d')"/"$(date -d @"${cleanup_process_start_time}" +'%Y%m%d_%H%M%S')"-cleanup-"${cleanup_job_log_suffix}".log
                else
                    print_error "Can't run post cleanup custom script: '${cleanup_job_hook_post}' as its filesystem bit is not executible!"
                fi
            ;;
            inventory )
                if [ -x "${inventory_job_hook_post}" ] ; then
                    print_notice "Executing post inventory custom script : '${inventory_job_hook_post}'"
                    ## script HOSTNAME CONTAINER_NAME TYPE INSTANCE_NUMBER NAME REPOSITORY_PATH ROUTINE_START_EPOCH PROCESS_START_EPOCH PROCESS_FINISH_EPOCH PROCESS_TOTAL_SECONDS EXITCODE LOGFILE SNAPSHOTS_TOTAL
                    "${inventory_job_hook_post}" "$(hostname)" "${CONTAINER_NAME}" INVENTORY "${inventory_instance_number}" "${inventory_job_log_suffix}" "${inventory_job_repository_path}" "${inventory_routines_start_time}" "${inventory_process_start_time}" "${inventory_process_finish_time}" "${inventory_process_total_time}" "${exitcode_inventory}" "${LOG_PATH}"/"$(date +'%Y%m%d')"/"$(date -d @"${inventory_process_start_time}" +'%Y%m%d_%H%M%S')"-inventory-"${inventory_job_log_suffix}".log ${inventory_job_snapshots_total}
                else
                    print_error "Can't run post inventory custom script: '${cleanup_job_hook_post}' as its filesystem bit is not executible!"
                fi
            ;;
            prune )
                if [ -x "${prune_job_hook_post}" ] ; then
                    print_notice "Executing post prune custom script : '${prune_job_hook_post}'"
                    ## script HOSTNAME CONTAINER_NAME TYPE INSTANCE_NUMBER NAME REPOSITORY_PATH ROUTINE_START_EPOCH PROCESS_START_EPOCH PROCESS_FINISH_EPOCH PROCESS_TOTAL_SECONDS EXITCODE LOGFILE PACKS_REVIEWED PACKS_DELETED_UNREFERENCED PACKS_REPACKED PACKS_REINDEXED PACKS_DELETED_OLD PACKS_INDEX_DELETED_OBSOLETE
                    "${prune_job_hook_post}" "$(hostname)" "${CONTAINER_NAME}" PRUNE "${prune_instance_number}" "${prune_job_log_suffix}" "${prune_job_repository_path}" "${prune_routines_start_time}" "${prune_process_start_time}" "${prune_process_finish_time}" "${prune_process_total_time}" "${exitcode_prune}" "${LOG_PATH}"/"$(date +'%Y%m%d')"/"$(date -d @"${prune_process_start_time}" +'%Y%m%d_%H%M%S')"-prune-"${prune_job_log_suffix}".log "${prune_job_packs_reviewed}" "{prune_job_packs_deleted_unreferenced}" "{prune_job_packs_repacked}" "{prune_job_packs_reindexed}" "{prune_job_index_deleted_obsolete}" "{prune_job_packs_deleted_old}"
                else
                    print_error "Can't run post prune custom script: '${prune_job_hook_post}' as its filesystem bit is not executible!"
                fi
            ;;
            unlock )
                if [ -x "${unlock_job_hook_post}" ] ; then
                    print_notice "Executing post unlock custom script : '${unlock_job_hook_post}'"
                    ## script HOSTNAME CONTAINER_NAME TYPE REPOSITORY_PATH ROUTINE_START_EPOCH PROCESS_START_EPOCH PROCESS_FINISH_EPOCH PROCESS_TOTAL_SECONDS EXITCODE LOGFILE
                    "${unlock_job_hook_post}" "$(hostname)" "${CONTAINER_NAME}" UNLOCK "${unlock_job_repository_path}" "${unlock_routines_start_time}" "${unlock_process_start_time}" "${unlock_process_finish_time}" "${unlock_process_total_time}" "${exitcode_unlock}" "${LOG_PATH}"/"$(date +'%Y%m%d')"/"$(date -d @"${unlock_process_start_time}" +'%Y%m%d_%H%M%S')"-unlock.log
                else
                    print_error "Can't run post unlock custom script: '${unlock_job_hook_post}' as its filesystem bit is not executible!"
                fi
            ;;
        esac
    }

    pre() {
        case "${1}" in
            backup )
                if [ -x "${backup_job_hook_pre}" ] ; then
                    print_notice "Executing pre snapshot custom script : '${backup_job_hook_pre}'"
                    ## script HOSTNAME CONTAINER_NAME TYPE INSTANCE_NUMBER NAME REPOSITORY_PATH ROUTINE_START_EPOCH BACKUP_PATH BACKUP_PATH_FILE
                    "${backup_job_hook_pre}" "$(hostname)" "${CONTAINER_NAME}" BACKUP "${backup_instance_number}" "${backup_job_log_suffix}" "${backup_job_repository_path}" "${backup_routines_start_time}" "${backup_job_snapshot_path}" "${backup_job_snapshot_path_file}"
                else
                    print_error "Can't run pre snapshot custom script: '${backup_job_hook_pre}' as its filesystem bit is not executible!"
                fi
            ;;
            check )
                if [ -x "${check_job_hook_pre}" ] ; then
                    print_notice "Executing pre check custom script : '${check_job_hook_pre}'"
                    ## script HOSTNAME CONTAINER_NAME TYPE INSTANCE_NUMBER NAME REPOSITORY_PATH ROUTINE_START_EPOCH
                    "${check_job_hook_pre}" "$(hostname)" "${CONTAINER_NAME}" CHECK "${check_instance_number}" "${check_job_log_suffix}" "${check_job_repository_path}" "${check_routines_start_time}"
                else
                    print_error "Can't run pre check custom script: '${check_job_hook_pre}' as its filesystem bit is not executible!"
                fi
            ;;
            cleanup )
                if [ -x "${cleanup_job_hook_pre}" ] ; then
                    print_notice "Executing pre cleanup custom script : '${cleanup_job_hook_pre}'"
                    ## script HOSTNAME CONTAINER_NAME TYPE INSTANCE_NUMBER NAME REPOSITORY_PATH ROUTINE_START_EPOCH
                    "${cleanup_job_hook_pre}" "$(hostname)" "${CONTAINER_NAME}" CLEANUP "${cleanup_instance_number}" "${cleanup_job_log_suffix}" "${cleanup_job_repository_path}" "${cleanup_routines_start_time}"
                else
                    print_error "Can't run pre cleanup custom script: '${cleanup_job_hook_pre}' as its filesystem bit is not executible!"
                fi
            ;;
            inventory )
                if [ -x "${inventory_job_hook_pre}" ] ; then
                    print_notice "Executing pre inventory custom script : '${inventory_job_hook_pre}'"
                    ## script HOSTNAME CONTAINER_NAME TYPE INSTANCE_NUMBER NAME REPOSITORY_PATH ROUTINE_START_EPOCH
                    "${inventory_job_hook_pre}" "$(hostname)" "${CONTAINER_NAME}" CLEANUP "${inventory_instance_number}" "${inventory_job_log_suffix}" "${inventory_job_repository_path}" "${inventory_routines_start_time}"
                else
                    print_error "Can't run pre inventory custom script: '${inventory_job_hook_pre}' as its filesystem bit is not executible!"
                fi
            ;;
            prune )
                if [ -x "${prune_job_hook_pre}" ] ; then
                    print_notice "Executing pre prune custom script : '${prune_job_hook_pre}'"
                    ## script HOSTNAME CONTAINER_NAME TYPE INSTANCE_NUMBER NAME REPOSITORY_PATH ROUTINE_START_EPOCH
                    "${prune_job_hook_pre}" "$(hostname)" "${CONTAINER_NAME}" PRUNE "${prune_instance_number}" "${prune_job_log_suffix}" "${prune_job_repository_path}" "${prune_routines_start_time}"
                else
                    print_error "Can't run pre prune custom script: '${prune_job_hook_pre}' as its filesystem bit is not executible!"
                fi
            ;;
            unlock )
                if [ -x "${unlock_job_hook_pre}" ] ; then
                    print_notice "Executing pre unlock custom script : '${unlock_job_hook_pre}'"
                    ## script HOSTNAME CONTAINER_NAME REPOSITORY_PATH ROUTINE_START_EPOCH
                    "${unlock_job_hook_pre}" "$(hostname)" "${CONTAINER_NAME}" "${unlock_job_repository_path}" "${unlock_routines_start_time}"
                else
                    print_error "Can't run pre unlock custom script: '${unlock_job_hook_pre}' as its filesystem bit is not executible!"
                fi
            ;;
        esac
    }

    case "${1}" in
        post ) post $2 ;;
        pre ) pre $2 ;;
    esac

}
notify() {
    notification_custom() {
        if [ -n "${NOTIFICATION_SCRIPT}" ] ; then
            if var_true "${NOTIFICATION_SCRIPT_SKIP_X_VERIFY}" ; then
                eval "${NOTIFICATION_SCRIPT}" "${1}" "${2}" "${3}" "${4}" "${5}"
            else
                if [ -x "${NOTIFICATION_SCRIPT}" ] ; then
                    print_notice "Found POST_SCRIPT environment variable. Executing '${NOTIFICATION_SCRIPT}"
                    # script timestamp logfile errorcode subject body
                    eval "${NOTIFICATION_SCRIPT}" "${1}" "${2}" "${3}" "${4}" "${5}"
                else
                    print_error "Can't execute NOTIFICATION_SCRIPT environment variable '${NOTIFICATION_SCRIPT}' as its filesystem bit is not executible!"
                fi
            fi
        else
            print_error "[notifications] No NOTIFICATION_SCRIPT variable set - Skipping sending Custom notifications"
        fi
    }

    notification_email() {
        if [ -z "${MAIL_FROM}" ] ; then print_error "[notifications] No MAIL_FROM variable set - Skipping sending Email notifications" ; skip_mail=true ; fi
        if [ -z "${MAIL_TO}" ] ; then print_error "[notifications] No MAIL_TO variable set - Skipping sending Email notifications" ; skip_mail=true ; fi
        if [ -z "${SMTP_HOST}" ] ; then print_error "[notifications] No SMTP_HOST variable set - Skipping sending Email notifications" ; skip_mail=true ; fi
        if [ -z "${SMTP_PORT}" ] ; then print_error "[notifications] No SMTP_PORT variable set - Skipping sending Email notifications" ; skip_mail=true ; fi
        if var_nottrue "${skip_mail}" ; then
            mail_recipients=$(echo "${MAIL_TO}" | tr "," "\n")
            for mail_recipient in $mail_recipients ; do
                cat <<EOF | s-nail -v \
                                        -r "${MAIL_FROM}" \
                                        -s "[restic] [${DOMAIN}] ${3}" \
                                        -S smtp="${SMTP_HOST}":"${SMTP_PORT}" \
                                        "${mail_recipient}"
Time: ${1}
Log File: {2}
Error Code: ${3}

${4}
EOF
            done
        fi
    }

    notification_mattermost() {
        if [ -z "${MATTERMOST_RECIPIENT}" ] ; then print_error "[notifications] No MATTERMOST_RECIPIENT variable set - Skipping sending Mattermost notifications" ; skip_mattermost=true ; fi
        if [ -z "${MATTERMOST_USERNAME}" ] ; then print_error "[notifications] No MATTERMOST_USERNAME variable set - Skipping sending Mattermost notifications" ; skip_mattermost=true ; fi
        if [ -z "${MATTERMOST_WEBHOOK_URL}" ] ; then print_error "[notifications] No MATTERMOST_WEBHOOK_URL variable set - Skipping sending Mattermost notifications" ; skip_mattermost=true ; fi
        if var_nottrue "${skip_mattermost}" ; then
        emoji=":bomb:"
        message="*[restic] ${3}*\n${4}\n*Timestamp:* ${1}\n*Logfile:* ${2}\n*Error Code: ${3}"
        mattermost_recipients=$(echo "${MATTERMOST_RECIPIENT}" | tr "," "\n")
            for mattermost_recipient in $mattermost_recipients ; do
                payload="payload={\"channel\": \"${mattermost_recipient//\"/\\\"}\", \"username\": \"${MATTERMOST_USERNAME//\"/\\\"}\", \"text\": \"${message//\"/\\\"}\", \"icon_emoji\": \"${emoji}\"}"
                silent /usr/bin/curl \
                                        -m 5 \
                                        --data-urlencode "${payload}" \
                                        "${MATTERMOST_WEBHOOK_URL}"
            done
        fi
    }

    notification_matrix() {
        if [ -z "${MATRIX_HOST}" ] ; then print_error "[notifications] No MATRIX_HOST variable set - Skipping sending matrix notifications" ; skip_matrix=true ; fi
        if [ -z "${MATRIX_ROOM}" ] ; then print_error "[notifications] No MATRIX_ROOM variable set - Skipping sending matrix notifications" ; skip_matrix=true ; fi
        if [ -z "${MATRIX_ACCESS_TOKEN}" ] ; then print_error "[notifications] No MATRIX_ACCESS_TOKEN variable set - Skipping sending matrix notifications" ; skip_matrix=true ; fi
        if var_nottrue "${skip_matrix}" ; then
            matrix_rooms=$(echo "${MATRIX_ROOM}" | tr "," "\n")
            for matrix_room in $matrix_rooms ; do
                curl \
                        -XPOST \
                        -d "{\"msgtype\":\"m.text\", \"body\":\"*[restic] ${3}*\n${4}\n*Timestamp:* ${1}\n*Logfile:* ${2}\n*Error Code: ${3}\"*hello}" \
                        "${MATRIX_HOST}/_matrix/client/r0/rooms/${matrix_room}/send/m.room.message?access_token=${MATRIX_ACCESS_TOKEN}"
            done
        fi
    }

    notification_rocketchat() {
        if [ -z "${ROCKETCHAT_RECIPIENT}" ] ; then print_error "[notifications] No ROCKETCHAT_RECIPIENT variable set - Skipping sending Rocket.Chat notifications" ; skip_rocketchat=true ; fi
        if [ -z "${ROCKETCHAT_USERNAME}" ] ; then print_error "[notifications] No ROCKETCHAT_USERNAME variable set - Skipping sending Rocket.Chat notifications" ; skip_rocketchat=true ; fi
        if [ -z "${ROCKETCHAT_WEBHOOK_URL}" ] ; then print_error "[notifications] No ROCKETCHAT_WEBHOOK_URL variable set - Skipping sending Rocket.Chat notifications" ; skip_rocketchat=true ; fi
        if var_nottrue "${skip_rocketchat}" ; then
            emoji=":bomb:"
            message="*[restic] ${3}*\n${4}\n*Timestamp:* ${1}\n*Logfile:* ${2}\n*Error Code: ${3}"
            rocketchat_recipients=$(echo "${ROCKETCHAT_RECIPIENT}" | tr "," "\n")
            for rocketchat_recipient in $rocketchat_recipients ; do
                payload="payload={\"channel\": \"${rocketchat_recipient//\"/\\\"}\", \"username\": \"${ROCKETCHAT_USERNAME//\"/\\\"}\", \"text\": \"${message//\"/\\\"}\", \"icon_emoji\": \"${emoji}\"}"
                silent /usr/bin/curl \
                                        -m 5 \
                                        --data-urlencode "${payload}" \
                                        "${ROCKETCHAT_WEBHOOK_URL}"
            done
        fi
    }

    # $1 timeststamp
    # $2 logfile
    # $2 errorcode
    # $3 subject
    # $4 body

    if var_true "${ENABLE_NOTIFICATIONS}" ; then
        notification_types=$(echo "${NOTIIFICATION_TYPE}" | tr "," "\n")
        for notification_type in $notification_types ; do
            case "${notification_type,,}" in
                "custom" )
                    print_debug "Sending Notification via custom"
                    notification_custom "${1}" "${2}" "${3}" "${4}" "${5}"
                ;;
                "email" | "mail" )
                    print_debug "Sending Notification via email"
                    notification_email "${1}" "${2}" "${3}" "${4}" "${5}"
                ;;
                "matrix" )
                    print_debug "Sending Notification via Matrix"
                    notification_matrix "${1}" "${2}" "${3}" "${4}" "${5}"
                ;;
                "mattermost" )
                    print_debug "Sending Notification via Mattermost"
                    notification_mattermost "${1}" "${2}" "${3}" "${4}" "${5}"
                ;;
                "rocketchat" )
                    print_debug "Sending Notification via Rocketchat"
                    notification_rocketchat "${1}" "${2}" "${3}" "${4}" "${5}"
                ;;
                * )
                    print_error "Unknown 'NOTIFICATION_TYPE=${notification_type}' environment value. "
                ;;
            esac
        done
    fi
}

repository() {
    backup() {
        process_limiter restic "${BACKUP_JOB_CONCURRENCY}" backup
        backup_process_start_time=$(date +%s)
        backup_job_file_log=$(cat <<EOF
# Job Started:                          $(date -d @"${backup_routines_start_time}" +'%Y%m%d_%H%M%S') (${backup_routines_start_time})
# Repository:                           $(echo "${backup_job_repository_path}" | sed "s|\(.*\):\(.*\):.*@\(.*\)|\1:\2:redacted@\3|g")
# Hostname:                             $(hostname)
# Container Name:                       $(echo "${CONTAINER_NAME}")

## Task:                                Backup (${backup_instance_number})
EOF
                        )
        if [ -n "${backup_job_snapshot_name}" ] ; then
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup Name:                         ${backup_job_snapshot_name}
EOF
                            )
        fi

        unset backup_job_args
        unset backup_job_snapshot_args

        if [ -n "${backup_job_snapshot_path_file}" ] ; then
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup Path File:                    ${backup_job_backup_file}
EOF
                        )
            backup_job_snapshot_args+="--files-from ${backup_job_snapshot_path_file} "
        fi

        if [ -n "${backup_job_snapshot_path}" ] ; then
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup Path:                         ${backup_job_snapshot_path}
EOF
                        )
            backup_job_snapshot_args+="${backup_job_snapshot_path} "
        fi

        backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup procedure started:            $(date -d @"${backup_process_start_time}" +'%Y-%m-%d %H:%M:%S') (${backup_process_start_time})
EOF
                        )
        backup_process_delay_time=$(echo $((backup_process_start_time-backup_routines_start_time)))
        if [ "${backup_process_delay_time}" -ge 5 ] ; then
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Delay in starting:                   $(echo "${backup_process_delay_time}" | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${backup_process_delay_time})
EOF
                            )
        fi

        if [ -n "${backup_job_snapshot_exclude}" ] ; then
            backup_job_snapshot_excludes=$(echo "${backup_job_snapshot_exclude}" | sed "s|'||g" | tr "," "\n")
            for exclude in ${backup_job_snapshot_excludes} ; do
                backup_job_args+="--exclude ${exclude} "
            done
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup Exclude:                      $(echo "${backup_job_snapshot_exclude}" | sed "s|'||g" )
EOF
                            )
        fi

        if [ -n "${backup_job_snapshot_exclude_file}" ] ; then
            if [ -f "${backup_job_snapshot_exclude_file}" ]; then
                backup_job_args+="--exclude_file ${BACKUP_EXCLUDE_FILE} "
                backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup Exclude File:                ${BACKUP_EXCLUDE_FILE}"
EOF
                                )
            else
                print_error "Cannot find EXCLUDE_FILE '${backup_job_snapshot_exclude_file}'"
                backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup Exclude File:                ERROR: Set but missing: ${BACKUP_EXCLUDE_FILE}
EOF
                                )

            fi
        fi

        if var_true "${backup_job_snapshot_dryrun}" ; then
            print_notice "DRY_RUN enabled - No backups will actually be written!"
            backup_job_args+="--dry-run "
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Dry Run enabled - No backups were actually performed"
EOF
                            )
        fi

        if [ -n "${backup_job_backup_args}" ] ; then
            backup_job_args+="${backup_job_backup_args} "
            backup_job_file_log=$(cat <<EOF
## Additional Arguments:                ${backup_job_backup_args}
EOF
                            )
        fi

        if [ -n "${backup_job_snapshot_verbosity_level}" ] ; then
            case "${backup_job_snapshot_verbosity_level,,}" in
                0 | normal | standard )
                    backup_job_snapshot_verbosity_level=0
                ;;
                1 | verbose )
                    backup_job_snapshot_verbosity_level=1
                ;;
                2 | verboseverbose | loud )
                    backup_job_snapshot_verbosity_level=2
                ;;
            esac
            backup_job_args+="--verbose=${backup_job_snapshot_verbosity_level} "
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Verbosity Level:                     ${backup_job_snapshot_verbosity_level}
EOF
                            )
        fi

        if [ -n "${backup_job_snapshot_name}" ] ; then
            backup_job_args+="--tag ${backup_job_snapshot_name} "
            backup_job_log_suffix=${backup_job_snapshot_name,,}
        else
            backup_job_log_suffix=${backup_instance_number}
        fi

        if [ -n "${backup_job_snapshot_tags}" ] ; then
            backup_snapshot_tags=$(echo "${backup_job_snapshot_tags}" | tr "," "\n")
            for backup_snapshot_tag in ${backup_snapshot_tags} ; do
                backup_job_args+="--tag ${backup_snapshot_tag} "
            done
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup Tags added:                  ${backup_job_snapshot_tags}
EOF
                                )
        fi

        if var_true "${DEBUG_MODE}" || [ "${CONTAINER_LOG_LEVEL,,}" = "debug" ]; then
            command_string="restic --cache-dir ${CACHE_PATH} --repo ${backup_job_repository_path} backup --host ${CONTAINER_NAME} --tag auto ${backup_job_args} ${backup_job_snapshot_args}"
            print_info "Command execution string: '${command_string}'"
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Debug Command String:                ${command_string}
EOF
                            )
        fi

        if [ -n "${backup_job_hook_pre}" ]; then
            hook backup pre
        fi

        print_info "Starting Backup Snapshot ${backup_job_log_suffix}"
        restic_repository=$(mktemp)
        echo "${backup_job_repository_path}" > "${restic_repository}"
        restic \
                --cache-dir "${CACHE_PATH}" \
                --repository-file "${restic_repository}" \
                backup \
                    --host "${CONTAINER_NAME}" --tag auto ${backup_job_args} ${backup_job_snapshot_args} \
                2> /tmp/"${backup_instance_number}"-backup-"${backup_routines_start_time}".error \
                > /tmp/"${backup_instance_number}"-backup-"${backup_routines_start_time}".log

        exitcode_backup=$?

        rm -rf "${restic_repository}"
        backup_process_finish_time="$(date +%s)"
        backup_process_total_time="$(echo $((backup_process_finish_time-backup_routines_start_time)))"

        case "${exitcode_backup}" in
            0 )
                print_info "Backup Successful"
                exitcode_backup_description="OK"
            ;;
            1 )
                exitcode_backup_description="FAIL"
                backup_job_error_log=true
                if grep -q "^Fatal: .*" /tmp/"${backup_instance_number}"-backup-"${backup_routines_start_time}".error ; then
                    backup_fatal_error="- Fatal errors detected"
                fi
                print_error "Backup Failed completely ${backup_fatal_error}"
                backup_job_error_log=true
                notify \
                        "$(date -d @"${backup_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}/$(date +'%Y%m%d')/$(date -d @${backup_routines_start_time} +'%Y%m%d_%H%M%S')-backup-${backup_job_log_suffix}.log" \
                        "{exitcode_backup}" \
                        "[FATAL] [${backup_job_log_suffix}] Backup failed completely" \
                        "Restic is failing to backup the '${backup_job_log_suffix}' job."
            ;;
            3 )
                exitcode_backup_description="ERROR"
                if grep -q "^error: .*" /tmp/"${backup_instance_number}"-backup-"${backup_routines_start_time}".error ; then
                    backup_error_count="$(grep -c "^error: .*" /tmp/"${backup_instance_number}"-backup-"${backup_routines_start_time}".error)"
                fi
                backup_error_description="#### Error Count: ${backup_error_count}"
                print_error "Backup completed with ${backup_error_count} errors detected"
                backup_job_error_log=true
                notify \
                        "$(date -d @"${backup_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}/$(date +'%Y%m%d')/$(date -d @${backup_routines_start_time} +'%Y%m%d_%H%M%S')-backup-${backup_job_log_suffix}.log" \
                        "{exitcode_backup}" \
                        "[WARN] [${backup_job_log_suffix}] Backup completed with errors" \
                        "Restic is failing to perform a full backup of the '${backup_job_log_suffix}' job."
            ;;
            130 )
                print_error "Backup Failed due to user cancellation"
                exitcode_backup_description="CANCELLED"
                backup_job_error_log=true
            ;;
            * )
                print_error "Backup Failed with exit code ${exitcode_backup}"
                exitcode_backup_description="UNKNOWN"
                backup_job_error_log=true
                notify \
                        "$(date -d @"${backup_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}/$(date +'%Y%m%d')/$(date -d @${backup_routines_start_time} +'%Y%m%d_%H%M%S')-backup-${backup_job_log_suffix}.log" \
                        "{exitcode_backup}" \
                        "[WARN] [${backup_job_log_suffix}] Backup failed due to unknown errors" \
                        "Restic is throwing an unknown error code while trying to backup the '${backup_job_log_suffix}' job."
            ;;
        esac

        backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup procedure finished:           $(date -d @"${backup_process_finish_time}" +'%Y-%m-%d %H:%M:%S') (${backup_process_finish_time})
## Backup procedure total time:         $(echo "${backup_process_total_time}" | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${backup_process_total_time})
## Backup procedure completion:         ${exitcode_backup_description} (${exitcode_backup})

### Backup Details
$(cat /tmp/"${backup_instance_number}"-backup-"${backup_routines_start_time}".log | sed "/^unchanged/d" )

EOF
                        )

        if var_true "${backup_job_error_log}" ; then
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF

#### Error Log
${backup_error_description}

$(cat "${backup_instance_number}"-backup-"${backup_routines_start_time}".error)

EOF
                            )
        fi

        sudo -u restic mkdir -p "${LOG_PATH}"/"$(date +'%Y%m%d')"
        cat << EOF | silent sudo -u restic tee "${LOG_PATH}"/"$(date +'%Y%m%d')"/"$(date -d @"${backup_process_start_time}" +'%Y%m%d_%H%M%S')"-backup-"${backup_job_log_suffix}".log
${backup_job_file_log}

EOF

        cd "${LOG_PATH}"/"$(date +'%Y%m%d')"
        ln -sf "$(date +'%Y%m%d')"/"$(date -d @"${backup_process_start_time}" +'%Y%m%d_%H%M%S')"-backup-"${backup_job_log_suffix}".log ../latest-backup-"${backup_job_log_suffix}".log

        backup_job_backup_summary_files=$(grep "^Files:" /tmp/"${backup_instance_number}"-backup-"${backup_routines_start_time}".log | xargs | sed "s|Files:||g")
        print_debug "[summary] Backup Summary Files: ${backup_job_backup_summary_files}"
        backup_job_backup_summary_files_new=$(echo "${backup_job_backup_summary_files}" | awk '{print $1}')
        print_debug "[summary] Files new: ${backup_job_backup_summary_files_new}"
        backup_job_backup_summary_files_changed=$(echo "${backup_job_backup_summary_files}" | awk '{print $3}')
        print_debug "[summary] Files changed: ${backup_job_backup_summary_files_changed}"
        backup_job_backup_summary_files_unmodified=$(echo "${backup_job_backup_summary_files}" | awk '{print $5}')
        print_debug "[summary] Files unmodified: ${backup_job_backup_summary_files_unmodified}"
        backup_job_backup_summary_directory=$(grep "^Dirs:" /tmp/"${backup_instance_number}"-backup-"${backup_routines_start_time}".log | xargs | sed "s|Dirs:||g")
        print_debug "[summary] Backup_summary_directory: ${backup_job_backup_summary_directory}"
        backup_job_backup_summary_directory_new=$(echo "${backup_job_backup_summary_directory}" | awk '{print $1}')
        print_debug "[summary] Directory new: ${backup_job_backup_summary_directory_new}"
        backup_job_backup_summary_directory_changed=$(echo "${backup_job_backup_summary_directory}" | awk '{print $3}')
        print_debug "[summary] Directory changed: ${backup_job_backup_summary_directory_changed}"
        backup_job_backup_summary_directory_unmodified=$(echo "${backup_job_backup_summary_directory}" | awk '{print $5}')
        print_debug "[summary] Directory unmodified: ${backup_job_backup_summary_directory_unmodified}"
        backup_job_backup_summary_added=$(grep "^Added to the repository:" /tmp/"${backup_instance_number}"-backup-"${backup_routines_start_time}".log | xargs | sed "s|Added to the repository:||g" | tr "," "\n")
        print_debug "[summary] Backup_summary added: ${backup_job_backup_summary_added}"
        backup_job_backup_summary_added_size_bytes=$(echo "${backup_job_backup_summary_added}" | awk '{print$1 $2}')
        if [ "${backup_job_backup_summary_added_size_bytes}" = "0B" ] ; then
            backup_job_backup_summary_added_size_bytes=0
        else
            backup_job_backup_summary_added_size_bytes=$(echo "${backup_job_backup_summary_added}" | awk '{print$1 $2}' | numfmt --from=iec-i --to=none --suffix=B 2>/dev/null| sed "s|B$||g")
        fi
        print_debug "[summary] added size bytes: ${backup_job_backup_summary_added_size_bytes}"
        backup_job_backup_summary_added_size_stored_bytes=$(echo "${backup_job_backup_summary_added}" | awk '{print$3 $4}' | sed -e "s|(||g" -e "s|)||g" )
        if [ "${backup_job_backup_summary_added_size_stored_bytes}" = "0B" ] ; then
            backup_job_backup_summary_added_size_stored_bytes=0
        else
            backup_job_backup_summary_added_size_stored_bytes=$(echo "${backup_job_backup_summary_added}" | awk '{print$3 $4}' | sed -e "s|(||g" -e "s|)||g" | numfmt --from=iec-i --to=none --suffix=B 2>/dev/null| sed "s|B$||g")
        fi
        print_debug "[summary] Added size stored bytes: ${backup_job_backup_summary_added_size_stored_bytes}"
        backup_job_backup_summary_processed=$(grep "^processed" /tmp/"${backup_instance_number}"-backup-"${backup_routines_start_time}".log | sed "s|processed||g" )
        print_debug "[summary] Backup_summary processed: ${backup_job_backup_summary_processed}"
        backup_job_backup_summary_proccessed_files=$(echo "${backup_job_backup_summary_processed}" | awk '{print $1}')
        print_debug "[summary] Processed files: ${backup_job_backup_summary_proccessed_files}"
        backup_job_backup_summary_processed_size_bytes=$(echo "${backup_job_backup_summary_processed}" | awk '{print $3 $4}')
        if [ "${backup_job_backup_summary_processed_size_bytes}" = "0B" ] ; then
            backup_job_backup_summary_processed_size_bytes=0
        else
            backup_job_backup_summary_processed_size_bytes=$(echo "${backup_job_backup_summary_processed}" | awk '{print $3 $4}' | numfmt --from=iec-i --to=none --suffix=B 2>/dev/null | sed "s|B$||g")
        fi
        print_debug "[summary] Processed size bytes: ${backup_job_backup_summary_processed_size_bytes}"
        if [ -n "${backup_error_count}" ] ; then
            backup_job_backup_summary_error_count="${backup_error_count}"
        else
            backup_job_backup_summary_error_count="0"
        fi
        rm -rf /tmp/"${backup_instance_number}"-backup-"${backup_routines_start_time}".*

        if var_true "${CONTAINER_ENABLE_MONITORING}" && [ "${CONTAINER_MONITORING_BACKEND,,}" = "zabbix" ]; then
            source /assets/defaults/03-monitoring
            print_notice "Sending Backup Statistics to Zabbix"
            silent zabbix_sender -c /etc/zabbix/zabbix_agentd.conf -k restic.backup -o '[{"{#NAME}":"'${backup_job_log_suffix}'"}]'
            cat <<EOF | silent zabbix_sender -c "${ZABBIX_CONFIG_PATH}"/"${ZABBIX_CONFIG_FILE}" -i -
- restic.backup.start_date.[${backup_job_log_suffix}] "${backup_routines_start_time}"
- restic.backup.status.[${backup_job_log_suffix}] "${exitcode_backup}"
- restic.backup.backup.duration.[${backup_job_log_suffix}] "${backup_process_total_time}"
- restic.backup.files.new.[${backup_job_log_suffix}] "${backup_job_backup_summary_files_new}"
- restic.backup.files.changed.[${backup_job_log_suffix}] "${backup_job_backup_summary_files_changed}"
- restic.backup.files.unmodified.[${backup_job_log_suffix}] "${backup_job_backup_summary_files_unmodified}"
- restic.backup.dirs.new.[${backup_job_log_suffix}] "${backup_job_backup_summary_directory_new}"
- restic.backup.dirs.changed.[${backup_job_log_suffix}] "${backup_job_backup_summary_directory_changed}"
- restic.backup.dirs.unmodified.[${backup_job_log_suffix}] "$"${backup_job_backup_summary_added_size_bytes}"{backup_job_backup_summary_directory_unmodified}"
- restic.backup.size.bytes.added.[${backup_job_log_suffix}]
- restic.backup.size.bytes.stored.[${backup_job_log_suffix}] "${backup_job_backup_summary_added_size_stored_bytes}"
- restic.backup.size.bytes.processed.[${backup_job_log_suffix}] "${backup_job_backup_summary_processed_size_bytes}"
- restic.backup.error.count.[${backup_job_log_suffix}] "${backup_job_backup_summary_error_count}"
EOF
        fi

        if [ -n "${backup_job_hook_post}" ]; then
            hook backup post
        fi

        backup_instance_vars=$(mktemp)
        set -o posix ; set | grep -oE "^backup_job_.*=" | tr " " "\n"| grep -oE ".*=" | sed "/--/d" > "${backup_instance_vars}"
        while read -r backup_instance_var ; do
            unset "$(echo "${backup_instance_var}" | cut -d = -f 1)"
        done < "${backup_instance_vars}"
        rm -rf "${backup_instance_vars}"
    }

    check() {
        if [ -z "${check_routines_start_time}" ] ; then check_routines_start_time=$(date +%s) ; fi
        check_job_file_log=$(cat <<EOF
## Job Started:                         $(date -d @${check_routines_start_time} +'%Y%m%d_%H%M%S') (${check_routines_start_time})
## Repository:                          $(echo ${check_job_repository_path} | sed "s|\(.*\):\(.*\):.*@\(.*\)|\1:\2:redacted@\3|g")
## Hostname:                            $(hostname)
## Container Name:                      $(echo "${CONTAINER_NAME}")

## Task:                                Check
EOF
                        )
        unset check_job_args
        process_limiter restic 1 check
        check_process_start_time=$(date +%s)
        check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF
## Check procedure started:             $(date -d @${check_process_start_time} +'%Y-%m-%d %H:%M:%S') (${check_process_start_time})
EOF
                        )

        check_process_delay_time=$(echo $((check_process_start_time-check_routines_start_time)))
        if [ "${check_process_delay_time}" -ge 5 ] ; then
            check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF
## Delay in starting:                   $(echo ${check_routines_delay_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${check_process_delay_time})
EOF
                            )
        fi

        if [ -n "${check_job_check_name}" ] ; then
            check_job_log_suffix="${check_job_check_name,,}"
        else
            check_job_log_suffix="${check_instance_number}"
        fi

        if [ -n "${check_job_check_use_cache}" ] ; then
            if var_true "${check_job_check_use_cache}" ; then
                check_job_args+="--with-cache "
            fi
            check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF
## Cache Enabled:                       ${check_job_check_use_cache}
EOF
                            )
        fi

        if [ -n "${check_job_check_amount}" ] ; then
            if [ "${check_job_check_amount}" = "all" ] ; then
                check_job_args+="--read-data "
                check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF
## Checking data:                       ALL
EOF
                                )
            else
                check_job_args+="--read-data-subset ${check_job_check_amount} "
                check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF
## Checking data:                       SUBSET ${check_job_check_amount}
EOF
                                )
            fi
        fi

        if [ -n "${check_job_check_args}" ] ; then
            check_job_args+="${check_job_check_args}"
            check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF
## Additional Arguments:                ${check_job_check_args}
EOF
                            )
        fi

        if var_true "${check_job_check_dryrun}" ; then
            print_notice "DRY_RUN enabled - No checks will actually be performed!"
            check_job_args+="--dry-run "
            check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF
## Dry Run enabled - No checks were actually performed"
EOF
                            )
        fi

        if [ -n "${check_job_verbosity_level}" ] ; then
            case "${check_job_verbosity_level,,}" in
                0 | normal | standard )
                    check_job_verbosity_level=0
                ;;
                1 | verbose )
                    check_job_verbosity_level=1
                ;;
                2 | verboseverbose | loud )
                    check_job_verbosity_level=2
                ;;
            esac
            check_job_args+="--verbose=${check_job_verbosity_level} "
            check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF
## Verbosity Level:                     ${check_job_verbosity_level}
EOF
                            )
        fi

        if [ -n "${check_job_hook_pre}" ]; then
            hook check pre
        fi

        process_limiter restic 1 check
        restic_repository=$(mktemp)
        echo "${check_job_repository_path}" > "${restic_repository}"
        restic \
                --cache-dir "${CACHE_PATH}" \
                --repository-file "${restic_repository}" \
                check ${check_job_args} \
                2> /tmp/check-${check_routines_start_time}.error \
                > /tmp/check-${check_routines_start_time}.log

        exitcode_check=$?

        check_process_finish_time=$(date +%s)
        check_process_total_time=$(echo $((check_process_finish_time-check_process_start_time)))

        case "${exitcode_check}" in
            0 )
                print_info "[check] Check Successful"
                exitcode_check_description="OK"
            ;;
            1 )
                print_error "[check] Check Failed completely"
                exitcode_check_description="FAIL"
                notify \
                        "$(date -d @"${check_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}"/"$(date +'%Y%m%d')"/"$(date -d @"${check_routines_start_time}" +'%Y%m%d_%H%M%S')"-check-"${check_job_log_suffix}".log \
                        "{exitcode_check}" \
                        "[FATAL] [${check_job_log_suffix}] Check failed completely" \
                        "Restic is failing to check the '${check_job_log_suffix}' job."
            ;;
            3 )
                print_error "[check] Check completed with errors"
                exitcode_check_description="ERROR"
                notify \
                        "$(date -d @"${check_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}"/"$(date +'%Y%m%d')"/"$(date -d @"${check_routines_start_time}" +'%Y%m%d_%H%M%S')"-check-"${check_job_log_suffix}".log \
                        "{exitcode_check}" \
                        "[WARN] [${check_job_log_suffix}] Check completed with errors" \
                        "Restic is failing to perform a full check of the '${check_job_log_suffix}' job."
            ;;
            * )
                print_error "[check] Check Failed with exit_code ${exitcode_check}"
                exitcode_check_description="UNKNOWN"
                notify \
                        "$(date -d @"${check_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}"/"$(date +'%Y%m%d')"/"$(date -d @"${check_routines_start_time}" +'%Y%m%d_%H%M%S')"-check-"${check_job_log_suffix}".log \
                        "{exitcode_check}" \
                        "[WARN] [${check_job_log_suffix}] Check failed due to unknown errors" \
                        "Restic is throwing an unknown error code while trying to check the '${check_job_log_suffix}' job."
            ;;
        esac

        check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF

## Check procedure finished:            $(date -d @"${check_process_finish_time}" +'%Y-%m-%d %H:%M:%S') (${check_process_finish_time})
## Check procedure total time:          $(echo "${check_process_total_time}" | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${check_process_total_time})
## Check procedure completion:          "${exitcode_check_description}" (${exitcode_check})

### Check Details
$(cat /tmp/check-"${check_routines_start_time}".log)

EOF
                        )

        if [ -s /tmp/check-"${check_routines_start_time}".error ] ; then
            if grep -q "^error: .*" /tmp/check-"${check_routines_start_time}".error ; then
                check_job_error_count=$(grep "^error: .*" /tmp/check-"${check_routines_start_time}".error | wc -l)
                print_error "[check] ${check_job_error_count} errors detected"
            fi
            check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF

### Error Log
## Errors: ${check_job_error_count}

$(cat /tmp/check-${check_routines_start_time}.error)


EOF
                            )
        fi

        sudo -u restic mkdir -p "${LOG_PATH}"/"$(date +'%Y%m%d')"
        cat << EOF | silent sudo -u restic tee "${LOG_PATH}"/"$(date +'%Y%m%d')"/"$(date -d @"${check_process_start_time}" +'%Y%m%d_%H%M%S')"-check-"${check_job_log_suffix}".log
${check_job_file_log}

EOF

        cd "${LOG_PATH}"/"$(date +'%Y%m%d')"
        ln -sf "$(date +'%Y%m%d')"/"$(date -d @"${check_process_start_time}" +'%Y%m%d_%H%M%S')"-check-"${check_job_log_suffix}".log ../latest-check-"${check_job_log_suffix}".log

        if grep -q "^pack .* not referenced in any index" /tmp/check-"${check_routines_start_time}".log ; then
            check_job_pack_unreferenced_count=$(grep "^pack .* not referenced in any index" /tmp/check-"${check_routines_start_time}".log | wc -l)
            print_debug "[check] ${check_job_pack_unreferenced_count} unreferenced packs detected"
        fi

        if grep -q "^\[.*\] .*% .* snapshots" /tmp/check-"${check_routines_start_time}".log ; then
            check_job_snapshots_processed=$(grep "^\[.*\] .*% .* snapshots" /tmp/check-"${check_routines_start_time}".log | awk '{print $3}')
            print_debug "[check] Processed ${check_job_snapshots_processed} of ${check_job_snapshots_total}"
        fi

        if var_true "${CONTAINER_ENABLE_MONITORING}" && [ "${CONTAINER_MONITORING_BACKEND,,}" = "zabbix" ]; then
            source /assets/defaults/03-monitoring
            print_notice "Sending Check Statistics to Zabbix"
            silent zabbix_sender -c /etc/zabbix/zabbix_agentd.conf -k restic.check -o '[{"{#NAME}":"'${check_job_log_suffix}'"}]'
            cat <<EOF | silent zabbix_sender -c "${ZABBIX_CONFIG_PATH}"/"${ZABBIX_CONFIG_FILE}" -i -
- restic.check.start_date.[${check_job_log_suffix}] "${check_routines_start_time}"
- restic.check.status.[${check_job_log_suffix}] "${exitcode_check}"
- restic.check.duration.[${check_job_log_suffix}] "${check_process_total_time}"
- restic.check.packs_unreferenced.[${check_job_log_suffix}] "${check_job_pack_unreferenced_count}"
- restic.check.snapshots.processed.[${check_job_log_suffix}] "${check_job_snapshots_processed}"
EOF
        fi

        if [ -n "${check_job_hook_post}" ]; then
            hook check post
        fi

        check_instance_vars=$(mktemp)
        set -o posix ; set | grep -oE "^check_job_.*=" | tr " " "\n" | grep -oE ".*=" | sed "/--/d" > "${check_instance_vars}"
        while read -r check_instance_var ; do
            unset "$(echo "${check_instance_var}" | cut -d = -f 1)"
        done < "${check_instance_vars}"
        rm -rf "${check_instance_vars}"
    }

    cleanup() {
        if [ -z "${cleanup_routines_start_time}" ] ; then cleanup_routines_start_time=$(date +%s) ; fi
            cleanup_job_file_log=$(cat <<EOF
## Job Started:                        $(date -d @${cleanup_routines_start_time} +'%Y%m%d_%H%M%S') (${cleanup_routines_start_time})
## Repository:                         $(echo ${cleanup_job_repository_path} | sed "s|\(.*\):\(.*\):.*@\(.*\)|\1:\2:redacted@\3|g")
## Hostname:                           $(hostname)
## Container Name:                     $(echo "${CONTAINER_NAME}")

## Task:                               Cleanup
EOF
                            )
            unset cleanup_job_args
            process_limiter restic 1 cleanup
            cleanup_process_start_time=$(date +%s)
            cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Cleanup procedure started:          $(date -d @${cleanup_process_start_time} +'%Y-%m-%d %H:%M:%S') (${cleanup_process_start_time})
EOF
                            )
            cleanup_process_delay_time=$(echo $((cleanup_process_finish_time-cleanup_process_start_time)))
            if [ "${cleanup_process_delay_time}" -ge "5" ] ; then
                cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Delay in starting:                   $(echo ${cleanup_process_delay_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${check_process_delay_time})
EOF
                                )
            fi

            if [ -n "${cleanup_job_cleanup_name}" ] ; then
                cleanup_job_log_suffix=${cleanup_job_cleanup_name,,}
            else
                cleanup_job_log_suffix=${cleanup_instance_number}
            fi

            if [ -n "${cleanup_job_retain_last}" ] ; then
                cleanup_job_keep_arg+="--keep-last ${cleanup_job_retain_last} "
                cleanup_job_log_keep_policy="${cleanup_job_retain_last} last "
            fi
            if [ -n "${cleanup_job_retain_hourly}" ] ; then
                cleanup_job_keep_arg+="--keep-hourly ${cleanup_job_retain_hourly} "
                cleanup_job_log_keep_policy+="${cleanup_job_retain_hourly} hourly "
            fi
            if [ -n "${cleanup_job_retain_daily}" ] ; then
                cleanup_job_keep_arg+="--keep-daily ${cleanup_job_retain_daily} "
                cleanup_job_log_keep_policy+="${cleanup_job_retain_daily} daily "
            fi
            if [ -n "${cleanup_job_retain_weekly}" ] ; then
                cleanup_job_keep_arg+="--keep-weekly ${cleanup_job_retain_weekly} "
                cleanup_job_log_keep_policy+="${cleanup_job_retain_weekly} weekly "
            fi
            if [ -n "${cleanup_job_retain_monthly}" ] ; then
                cleanup_job_keep_arg+="--keep-monthly ${cleanup_job_retain_monthly} "
                cleanup_job_log_keep_policy+="${cleanup_job_retain_monthly} monthly "
            fi
            if [ -n "${cleanup_job_retain_yearly}" ] ; then
                cleanup_job_keep_arg+="--keep-yearly ${cleanup_job_retain_yearly} "
                cleanup_job_log_keep_policy+="${cleanup_job_retain_yearly} yearly"
            fi

            if [ -n "${cleanup_job_retain_tag}" ] ; then
                cleanup_retain_tags=$(echo "${cleanup_job_retain_tag}" | tr "," "\n")
                for cleanup_retain_tag in ${cleanup_retain_tags} ; do
                    cleanup_job_keep_arg+="--keep-tag ${cleanup_retain_tag}"
                done
            fi

            if [ -n "${cleanup_job_log_keep_policy}" ] ; then
                cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Cleanup Policy:                     ${cleanup_job_log_keep_policy}
EOF
                                    )
            fi

            if [ -n "${cleanup_job_log_retain_tag}" ] ; then
                cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
cleanup_job_log_retain_tag="## Skipping tags:                      ${cleanup_job_retain_tag}
EOF
                                )
            fi

            if [ -n "${cleanup_job_keep_arg}" ] ; then
                cleanup_job_args+=${cleanup_job_keep_arg}
            fi

            case "${cleanup_job_cleanup_repack}" in
                cacheable )
                    cleanup_job_args+="--repack-cacheable-only "
                    cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Repack                              Cacheable Only
EOF
                                        )
                ;;
                small )
                    cleanup_job_args+="--repack-small "
                    cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Repack                              Small
EOF
                                        )
                ;;
                uncompressed )
                    cleanup_job_args+="--repack-uncompressed "
                    cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Repack                              Uncompressed
EOF
                                        )
                ;;
                none )
                    cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Repack                              None
EOF
                                        )
                ;;
            esac

            if var_true "${cleanup_job_auto_prune}" ; then
                print_notice "AUTO_PRUNE enabled - Will prune after successful cleanup"
                cleanup_job_args+="--prune "
                cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Auto Prune                          Enabled
EOF
                                )
            fi

            if var_true "${cleanup_job_cleanup_dryrun}" ; then
                print_notice "DRY_RUN enabled - No cleanup will actually be performed!"
                cleanup_job_args+="--dry-run "
                cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Dry Run enabled - No cleanup was actually performed
EOF
                                )
            fi

            if [ -n "${cleanup_job_cleanup_args}" ] ; then
                cleanup_job_args+="${cleanup_job_cleanup_args} "
                cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Additional Arguments:                ${cleanup_job_cleanup_args}
EOF
                                )
            fi

            if [ -n "${cleanup_job_cleanup_verbosity_level}" ] ; then
                case "${cleanup_job_cleanup_verbosity_level,,}" in
                    0 | normal | standard )
                        cleanup_job_cleanup_verbosity_level=0
                    ;;
                    1 | verbose )
                        cleanup_job_cleanup_verbosity_level=1
                    ;;
                    2 | verboseverbose | loud )
                        cleanup_job_cleanup_verbosity_level=2
                    ;;
                esac
                cleanup_job_args+="--verbose=${cleanup_job_cleanup_verbosity_level} "
                cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Verbosity Level:                    ${cleanup_job_cleanup_verbosity_level}
EOF
                                )
            fi

            if var_true "${DEBUG_MODE}" || [ ${CONTAINER_LOG_LEVEL,,} = "debug" ]; then
                cleanup_command_string="restic --repo ${cleanup_job_repository_path} forget --host ${CONTAINER_NAME} --group-by '' ${cleanup_job_args}"
                print_debug "Command execution string: '${cleanup_command_string}'"
                cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Debug Command String:               ${cleanup_command_string}
EOF
                                )
            fi

            if [ -n "${cleanup_job_hook_pre}" ]; then
                hook cleanup pre
            fi

            print_info "Starting cleanup of old backups"
            restic_repository=$(mktemp)
            echo "${cleanup_job_repository_path}" > "${restic_repository}"
            restic \
                    --cache-dir "${CACHE_PATH}" \
                    --repository-file "${restic_repository}" \
                    forget \
                    --host "${CONTAINER_NAME}" \
                    --group-by '' ${cleanup_job_args} \
                    2> /tmp/"${cleanup_instance_number}"-cleanup-"${cleanup_routines_start_time}".error \
                    > /tmp/"${cleanup_instance_number}"-cleanup-"${cleanup_routines_start_time}".log

            exitcode_cleanup="$?"
            rm  -rf "${restic_repository}"
            cleanup_process_finish_time="$(date +%s)"
            cleanup_process_total_time="$(echo $((cleanup_process_finish_time-cleanup_routines_start_time)))"

            case "${exitcode_cleanup}" in
                0 )
                    print_info "[cleanup] Cleanup successful"
                    exitcode_cleanup_description="OK"
                ;;
                1 )
                    print_error "[cleanup] Cleanup failed completely"
                    exitcode_cleanup_description="FAIL"
                    notify \
                        "$(date -d @"${cleanup_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}/$(date +'%Y%m%d')/$(date -d @${cleanup_routines_start_time} +'%Y%m%d_%H%M%S')-cleanup-${cleanup_job_log_suffix}.log" \
                        "{exitcode_cleanup}" \
                        "[FATAL] [${cleanup_job_log_suffix}] Cleanup failed completely" \
                        "Restic is failing to cleanup the '${cleanup_job_log_suffix}' job."
                ;;
                3 )
                    print_error "[cleanup] Cleanup completed with errors"
                    exitcode_cleanup_description="ERROR"
                    notify \
                        "$(date -d @"${cleanup_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}/$(date +'%Y%m%d')/$(date -d @${cleanup_routines_start_time} +'%Y%m%d_%H%M%S')-cleanup-${cleanup_job_log_suffix}.log" \
                        "{exitcode_cleanup}" \
                        "[WARN] [${cleanup_job_log_suffix}] Cleanup completed with errors" \
                        "Restic is failing to perform a full cleanup of the '${cleanup_job_log_suffix}' job."
                ;;
                130 )
                    print_error "[cleanup] Cleanup failed due to user cancellation"
                    exitcode_cleanup_description="CANCELLED"
                ;;
                * )
                    print_error "[cleanup] Cleanup Failed with exit_code ${exitcode_cleanup}"
                    exitcode_cleanup_description="UNKNOWN"
                    notify \
                        "$(date -d @"${cleanup_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}/$(date +'%Y%m%d')/$(date -d @${cleanup_routines_start_time} +'%Y%m%d_%H%M%S')-cleanup-${cleanup_job_log_suffix}.log" \
                        "{exitcode_cleanup}" \
                        "[WARN] [${cleanup_job_log_suffix}] Cleanup failed due to unknown errors" \
                        "Restic is throwing an unknown error code while trying to cleanup the '${cleanup_job_log_suffix}' job."
                ;;
            esac

            cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Cleanup procedure finished:         $(date -d @${cleanup_process_finish_time} +'%Y-%m-%d %H:%M:%S') (${cleanup_process_finish_time})
## Cleanup procedure total time:       $(echo ${cleanup_routines_total_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${cleanup_process_total_time})
## Cleanup procedure completion:       ${exitcode_cleanup_description} (${exitcode_cleanup})

### Cleanup Details
$(cat /tmp/${cleanup_instance_number}-cleanup-${cleanup_routines_start_time}.log)

EOF
                            )

        if [ -s /tmp/${cleanup_instance_number}-cleanup-${cleanup_routines_start_time}.error ] ; then
            if grep -q "^error: .*" /tmp/${cleanup_instance_number}-cleanup-"${cleanup_routines_start_time}".error ; then
                cleanup_job_error_count=$(grep "^error: .*" /tmp/${cleanup_instance_number}-cleanup-${cleanup_routines_start_time}.error | wc -l)
                print_error "[Cleanup] ${cleanup_job_error_count} errors detected"
            fi
            cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF

### Error Log
## Errors: ${cleanup_job_error_count}

$(cat /tmp/${cleanup_instance_number}-cleanup-${cleanup_routines_start_time}.error)

EOF
                            )
        fi

        rm -rf /tmp/"${cleanup_instance_number}"-cleanup-"${cleanup_routines_start_time}".*
        sudo -u restic mkdir -p "${LOG_PATH}"/"$(date +'%Y%m%d')"
        cat << EOF | silent sudo -u restic tee -a "${LOG_PATH}"/"$(date +'%Y%m%d')"/"$(date -d @"${cleanup_process_start_time}" +'%Y%m%d_%H%M%S')"-cleanup-${cleanup_job_log_suffix}.log
${cleanup_job_file_log}
EOF

        cd "${LOG_PATH}"/"$(date +'%Y%m%d')"
        ln -sf "$(date +'%Y%m%d')"/"$(date -d @"${cleanup_process_start_time}" +'%Y%m%d_%H%M%S')"-cleanup-"${cleanup_job_log_suffix}".log ../latest-cleanup-"${cleanup_job_log_suffix}".log

        if var_true "${CONTAINER_ENABLE_MONITORING}" && [ "${CONTAINER_MONITORING_BACKEND,,}" = "zabbix" ]; then
            source /assets/defaults/03-monitoring
            print_notice "Sending Cleanup Statistics to Zabbix"
            silent zabbix_sender -c /etc/zabbix/zabbix_agentd.conf -k restic.cleanup -o '[{"{#NAME}":"'${cleanup_job_log_suffix}'"}]'
            cat <<EOF | silent zabbix_sender -c "${ZABBIX_CONFIG_PATH}"/"${ZABBIX_CONFIG_FILE}" -i -
- restic.cleanup.start_date.[${cleanup_job_log_suffix}] "${cleanup_routines_start_time}"
- restic.cleanup.status.[${cleanup_job_log_suffix}] "${exitcode_cleanup}"
- restic.cleanup.duration.[${cleanup_job_log_suffix}] "${cleanup_process_total_time}"
EOF
        fi

        if [ -n "${cleanup_job_hook_post}" ]; then
            hook cleanup post
        fi

        cleanup_instance_vars=$(mktemp)
        set -o posix ; set | grep -oE "^cleanup_job_.*=" | tr " " "\n" | grep -oE ".*=" | sed "/--/d" > "${cleanup_instance_vars}"

        while read -r cleanup_instance_var ; do
            print_debug "Unsetting '$(echo "${cleanup_instance_var}" | cut -d = -f 1)'"
            unset "$(echo "${cleanup_instance_var}" | cut -d = -f 1)"
        done < "${cleanup_instance_vars}"
        rm -rf "${cleanup_instance_vars}"
    }

    init() {
        while read -r repository_to_init ; do
            if [ -v "$(echo "${repository_to_init}" | awk '{print $1}')"_SKIP_INIT ] && [ "$(set -o posix; set | grep -E "^${repository_to_init}_SKIP_INIT" | cut -d = -f 2)" = "TRUE" ]; then
                skip_init=true
            elif [ -n "${DEFAULT_SKIP_INIT}" ] && [ "${DEFAULT_SKIP_INIT}" != "true" ]; then
                skip_init=true
            elif [ -n "${SKIP_INIT}" ] && [ "${SKIP_INIT}" != "true" ]; then
                skip_init=true
            fi

            if var_nottrue "${skip_init}" ; then
                print_debug "Initializing Repository: ${repository_to_init}"
                if grep -q "ENABLE_SERVER=TRUE" /tmp/.container/toi_restic/CONTAINER_MODE ; then
                    print_notice "Delaying Initialization Routines until REST Server is running"
                    wait_for_port 127.0.0.1 "${SERVER_LISTEN_PORT}"
                elif [ -v "$(echo "${repository_to_init}" | awk '{print $1}')"_DELAY_INIT ] && [ "$(set -o posix; set | grep -E "^${repository_to_init}_DELAY_INIT" | cut -d = -f 2)" != "unset" ]; then
                    delay_init=$(set -o posix; set | grep -E "^${repository_to_init}_DELAY_INIT" | cut -d = -f 2)
                elif [ -n "${DEFAULT_DELAY_INIT}" ] && [ "${DEFAULT_DELAY_INIT}" != "unset" ]; then
                    delay_init=${DEFAULT_DELAY_INIT}
                elif [ -n "${DELAY_INIT}" ] && [ "${DELAY_INIT}" != "unset" ]; then
                    delay_init=${DELAY_INIT}
                fi

                if [ -n "${delay_init}" ] ; then
                    print_notice "Delaying repository initialization of $(echo ${repository_to_init} | awk '{print $1}') for ${delay_init} seconds"
                    sleep "${delay_init}"
                fi

                case "$(echo "${repository_to_init}" | awk '{print $1}')" in
                    BACKUP* )
                        if [ "$(echo ${repository_to_init} | awk '{print $1}')" = "BACKUP01" ] ; then bootstrap_variables upgrade BACKUP ; fi
                        if [ -v "$(echo ${repository_to_init} | awk '{print $1}')"_REPOSITORY_PASS ] && [ "$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
                            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)
                        elif [ -n "${DEFAULT_BACKUP_REPOSITORY_PASS}" ] && [ "${DEFAULT_BACKUP_REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${DEFAULT_BACKUP_REPOSITORY_PASS}
                        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${REPOSITORY_PASS}
                        fi
                    ;;
                    CHECK* )
                        if [ "$(echo ${repository_to_init} | awk '{print $1}')" = "CHECK01" ] ; then bootstrap_variables upgrade CHECK ; fi
                        if [ -v "$(echo "${repository_to_init}" | awk '{print $1}')"_REPOSITORY_PASS ] && [ "$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
                            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)
                        elif [ -n "${DEFAULT_CHECK_REPOSITORY_PASS}" ] && [ "${DEFAULT_CHECK_REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${DEFAULT_CHECK_REPOSITORY_PASS}
                        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${REPOSITORY_PASS}
                        fi
                    ;;
                    CLEANUP* )
                        if [ "$(echo ${repository_to_init} | awk '{print $1}')" = "CLEANUP01" ] ; then bootstrap_variables upgrade CLEANUP ; fi
                        if [ -v "$(echo "${repository_to_init}" | awk '{print $1}')"_REPOSITORY_PASS ] && [ "$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
                            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)
                        elif [ -n "${DEFAULT_CLEANUP_REPOSITORY_PASS}" ] && [ "${DEFAULT_CLEANUP_REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${DEFAULT_CLEANUP_REPOSITORY_PASS}
                        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${REPOSITORY_PASS}
                        fi
                    ;;
                    INVENTORY* )
                        if [ "$(echo ${repository_to_init} | awk '{print $1}')" = "INVENTORY01" ] ; then bootstrap_variables upgrade INVENTORY ; fi
                        if [ -v "$(echo "${repository_to_init}" | awk '{print $1}')"_REPOSITORY_PASS ] && [ "$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
                            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)
                        elif [ -n "${DEFAULT_INVENTORY_REPOSITORY_PASS}" ] && [ "${DEFAULT_INVENTORY_REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${DEFAULT_INVENTORY_REPOSITORY_PASS}
                        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${REPOSITORY_PASS}
                        fi
                    ;;
                    PRUNE* )
                        if [ "$(echo "${repository_to_init}" | awk '{print $1}')" = "PRUNE01" ] ; then bootstrap_variables upgrade PRUNE ; fi
                        if [ -v "$(echo ${repository_to_init} | awk '{print $1}')"_REPOSITORY_PASS ] && [ "$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
                            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)
                        elif [ -n "${DEFAULT_PRUNE_REPOSITORY_PASS}" ] && [ "${DEFAULT_PRUNE_REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${DEFAULT_PRUNE_REPOSITORY_PASS}
                        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${REPOSITORY_PASS}
                        fi

                    ;;
                esac

                if [ -v "$(echo "${repository_to_init}" | awk '{print $1}')"_INIT_ARGS ] && [ "$(set -o posix; set | grep -E "^${repository_to_init}_INIT_ARGS" | cut -d = -f 2)" != "unset" ]; then
                    repository_init_arg=$(set -o posix; set | grep -E "^${repository_to_init}_INIT_ARGS" | cut -d = -f 2)
                elif [ -n "${DEFAULT_INIT_ARGS}" ] && [ "${DEFAULT_INIT_ARGS}" != "unset" ]; then
                    repository_init_arg=${DEFAULT_INIT_ARGS}
                fi

                restic_repository=$(mktemp)
                echo "${repository_to_init}" | awk '{print $2}' > "${restic_repository}"
                silent restic \
                                --cache-dir "${CACHE_PATH}" \
                                --repository-file "${restic_repository}" \
                                snapshots \
                                --host "${CONTAINER_NAME}" \
                                --quiet ${repository_init_arg}
                exitcode_init=$?
                rm -rf "${restic_repository}"

                print_debug "[check_init_repository] [${repository_to_init}] Check exit code ${exitcode_init}"

                if [ "${exitcode_init}" != "0" ]; then
                    print_debug "[check_repository] No repository found"
                    print_notice "[check_repository] Initializing Repository '$(echo "${repository_to_init}" | awk '{print $1}')'"

                    restic_repository=$(mktemp)
                    echo "${repository_to_init}" | awk '{print $2}' > "${restic_repository}"

                    silent restic \
                                    --cache-dir "${CACHE_PATH}" \
                                    --repository-file "${restic_repository}" \
                                    init ${repository_init_arg}
                    exitcode_init=$?
                    rm -rf "${restic_repository}"

                    if [ "${exitcode_init}" != 0 ]; then
                        print_error "Failed to init the repository: '$(echo "${repository_to_init}" | awk '{print $1}')':"

                        restic_repository=$(mktemp)
                        echo "${repository_to_init}" | awk '{print $2}' > "${restic_repository}"
                        restic \
                                --cache-dir "${CACHE_PATH}" \
                                --repository-file "${restic_repository}" \
                                init ${repository_init_arg}

                        notify \
                            "$(date +'%Y%m%d_%H%M%S')" \
                            "See container console logs" \
                            "{exitcode_init}" \
                            "[FATAL] [${repository_to_init}] Cannot initialize repository" \
                            "Restic is failing to perform a initialize the repository  '${repository_to_init}' job."

                        return "${exitcode_init}"
                    else
                        return "${exitcode_init}"
                    fi
                else
                    return "${exitcode_init}"
                fi
            else
                print_debug "Skipped Initialization routines for '$(echo "${repository_to_init}" | awk '{print $1}')'"
                exitcode_init=0
                return 0
            fi
        done < "/tmp/.container/toi_restic/INIT_REPOSITORIES"
    }

    inventory() {
        bootstrap_variables inventory_init
        if [ -z "${inventory_routines_start_time}" ] ; then inventory_routines_start_time=$(date +%s) ; fi
            inventory_job_file_log=$(cat <<EOF
## Job Started:                         $(date -d @${inventory_routines_start_time} +'%Y%m%d_%H%M%S') (${inventory_routines_start_time})
## Repository:                          $(echo ${inventory_job_repository_path} | sed "s|\(.*\):\(.*\):.*@\(.*\)|\1:\2:redacted@\3|g")
## Hostname:                            $(hostname)
## Container Name:                      $(echo "${CONTAINER_NAME}")

## Task:                                Inventory
EOF
                       )

        process_limiter restic 1 inventory
        inventory_process_start_time=$(date +%s)
        inventory_job_file_log=$(echo "${inventory_job_file_log}" ; cat <<EOF
## Inventory procedure started:      $(date -d @${inventory_process_start_time} +'%Y-%m-%d %H:%M:%S') (${inventory_process_start_time})
EOF
                        )

        inventory_process_delay_time=$(echo $((inventory_process_start_time-inventory_routines_start_time)))
        if [ "${inventory_process_delay_time}" -ge 5 ] ; then
            inventory_job_file_log=$(echo "${inventory_job_file_log}" ; cat <<EOF
## Delay in starting:                   $(echo ${inventory_routines_delay_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${inventory_process_delay_time})
EOF
                            )
        fi

        if [ -n "${inventory_job_inventory_name}" ] ; then
            inventory_job_log_suffix=${inventory_job_inventory_name,,}
        else
            inventory_job_log_suffix=${inventory_instance_number}
        fi

        if [ -n "${inventory_job_hook_pre}" ]; then
            hook inventory pre
        fi

        restic_repository=$(mktemp)
        echo "${inventory_job_repository_path}" > "${restic_repository}"
        process_limiter restic 1 inventory
        restic \
                --cache-dir "${CACHE_PATH}" \
                --repository-file "${restic_repository}" \
                snapshots ${inventory_job_args} \
                2> /tmp/inventory-${inventory_routines_start_time}.error \
                > /tmp/inventory-${inventory_routines_start_time}.log

        exitcode_inventory=$?
        rm -rf "${restic_repository}"
        inventory_process_finish_time=$(date +%s)
        inventory_process_total_time=$(echo $((inventory_process_finish_time-inventory_process_start_time)))

        case "${exitcode_inventory}" in
            0 )
                if [ -s /tmp/inventory-"${inventory_routines_start_time}".error ] || [ -s /tmp/inventory-"${inventory_routines_start_time}".log ] ; then
                    print_info "[inventory] Inventory Successful"
                    exitcode_inventory_description="OK"
                else
                    print_debug "[inventory] Inventory unnecessary"
                    exitcode_inventory_description="NOT_NECESSARY"
                    exitcode_inventory=23
                fi
            ;;
            1 )
                print_error "[inventory] Inventory Failed completely"
                exitcode_inventory_description="FAIL"
                notify \
                        "$(date -d @"${inventory_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}/$(date +'%Y%m%d')/$(date -d @${inventory_routines_start_time} +'%Y%m%d_%H%M%S')-inventory-${inventory_job_log_suffix}.log" \
                        "{exitcode_inventory}" \
                        "[FATAL] [${inventory_job_log_suffix}] Inventory failed completely" \
                        "Restic is failing to inventory the '${inventory_job_log_suffix}' job."
            ;;
            3 )
                print_error "[inventory] Inventory completed with errors"
                exitcode_inventory_description="ERROR"
                notify \
                        "$(date -d @"${inventory_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}/$(date +'%Y%m%d')/$(date -d @${inventory_routines_start_time} +'%Y%m%d_%H%M%S')-inventory-${inventory_job_log_suffix}.log" \
                        "{exitcode_inventory}" \
                        "[WARN] [${inventory_job_log_suffix}] Inventory completed with errors" \
                        "Restic is failing to perform a full inventory of the '${inventory_job_log_suffix}' job."
            ;;
            * )
                print_error "[inventory] Inventory Failed with exit_code ${exitcode_inventory}"
                exitcode_inventory_description="UNKNOWN"
                notify \
                        "$(date -d @"${inventory_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}/$(date +'%Y%m%d')/$(date -d @${inventory_routines_start_time} +'%Y%m%d_%H%M%S')-inventory-${inventory_job_log_suffix}.log" \
                        "{exitcode_inventory}" \
                        "[WARN] [${inventory_job_log_suffix}] Inventory failed due to unknown errors" \
                        "Restic is throwing an unknown error code while trying to perform the '${inventory_job_log_suffix}' job."
            ;;
        esac

        inventory_job_file_log=$(echo "${inventory_job_file_log}" ; cat <<EOF

## Inventory procedure finished:        $(date -d @${inventory_process_finish_time} +'%Y-%m-%d %H:%M:%S') (${inventory_process_finish_time})
## Inventory procedure total time:      $(echo ${inventory_process_total_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${inventory_process_total_time})
## Inventory procedure completion:      ${exitcode_inventory_description} (${exitcode_inventory})

### Inventory Details
$(cat /tmp/inventory-${inventory_routines_start_time}.log | awk '/ID/,/snapshots/')

EOF
                        )


        if [ -s /tmp/inventory-"${inventory_routines_start_time}".log ] ; then
            sudo -u restic mkdir -p "${LOG_PATH}"/"$(date +'%Y%m%d')"
            cat << EOF | silent sudo -u restic tee "${LOG_PATH}"/"$(date +'%Y%m%d')"/"$(date -d @"${inventory_process_start_time}" +'%Y%m%d_%H%M%S')"-inventory-${inventory_job_log_suffix}.log
${inventory_job_file_log}

EOF
            cd "${LOG_PATH}"/"$(date +'%Y%m%d')"
            ln -sf "$(date +'%Y%m%d')"/"$(date -d @"${inventory_process_start_time}" +'%Y%m%d_%H%M%S')"-inventory-${inventory_job_log_suffix}.log ../latest-inventory-${inventory_job_log_suffix}.log
        fi

        inventory_job_snapshots_total=$(cat /tmp/inventory-"${inventory_routines_start_time}".log  | grep -E "[0-9]. snapshots$" | awk '{print $1}')
        if var_true "${CONTAINER_ENABLE_MONITORING}" && [ "${CONTAINER_MONITORING_BACKEND,,}" = "zabbix" ]; then
            source /assets/defaults/03-monitoring
            print_notice "Sending Inventory Statistics to Zabbix"
            silent zabbix_sender -c /etc/zabbix/zabbix_agentd.conf -k restic.inventory -o '[{"{#NAME}":"'${inventory_job_log_suffix}'"}]'
            cat <<EOF | silent zabbix_sender -c "${ZABBIX_CONFIG_PATH}"/"${ZABBIX_CONFIG_FILE}" -i -
- restic.inventory.start_date.[${inventory_job_log_suffix}] "${inventory_routines_start_time}"
- restic.inventory.status.[${inventory_job_log_suffix}] "${exitcode_inventory}"
- restic.inventory.duration.[${inventory_job_log_suffix}] "${inventory_process_total_time}"
- restic.inventory.snapshots.total.[${inventory_job_log_suffix}] "${inventory_job_snapshots_total}"
EOF
        fi

        if [ -n "${inventory_job_hook_pre}" ]; then
            hook inventory post
        fi

        unset inventory_job_args
        rm -rf /tmp/inventory-"${inventory_routines_start_time}".*
    }

    prune() {
        if [ -z "${prune_routines_start_time}" ] ; then prune_routines_start_time=$(date +%s) ; fi
        prune_job_file_log=$(cat <<EOF
## Job Started:                         $(date -d @${prune_routines_start_time} +'%Y%m%d_%H%M%S') (${prune_routines_start_time})
## Repository:                          $(echo ${prune_job_repository_path} | sed "s|\(.*\):\(.*\):.*@\(.*\)|\1:\2:redacted@\3|g")
## Hostname:                            $(hostname)
## Container Name:                      $(echo ${CONTAINER_NAME})

## Task:                                Prune
EOF
                            )
        unset prune_job_args
        process_limiter restic 1 prune
        prune_process_start_time=$(date +%s)
        prune_job_file_log=$(echo "${prune_job_file_log}" ; cat <<EOF
## Prune procedure started:             $(date -d @${prune_process_start_time} +'%Y-%m-%d %H:%M:%S') (${prune_process_start_time})
EOF
                            )

        prune_process_delay_time=$(echo $((prune_process_start_time-prune_routines_start_time)))
        if [ "${prune_process_delay_time}" -ge 5 ] ; then
            prune_job_file_log=$(echo "${prune_job_file_log}" ; cat <<EOF
## Delay in starting:                   $(echo ${prune_routines_delay_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${prune_process_delay_time})
EOF
                                )
        fi

        if [ -n "${prune_job_prune_name}" ] ; then
            prune_job_log_suffix=${prune_job_prune_name,,}
        else
            prune_job_log_suffix=${prune_instance_number}
        fi

        if [ -n "${prune_job_prune_args}" ] ; then
            prune_job_args+="${prune_job_prune_args}"
            prune_job_file_log=$(echo "${prune_job_file_log}" ; cat <<EOF
## Additional Arguments:                ${prune_job_prune_args}
EOF
                            )
        fi

        if var_true "${prune_job_prune_dryrun}" ; then
            print_notice "DRY_RUN enabled - No pruning will actually be performed!"
            prune_job_args+="--dry-run "
            prune_job_file_log=$(echo "${prunes_file_log}" ; cat <<EOF
## Dry Run enabled - No prunes were actually performed"
EOF
                            )
        fi

        if [ -n "${prune_job_verbosity_level}" ] ; then
            case "${prune_job_verbosity_level,,}" in
                0 | normal | standard )
                    prune_job_verbosity_level=0
                ;;
                1 | verbose )
                    prune_job_verbosity_level=1
                ;;
                2 | verboseverbose | loud )
                    prune_job_verbosity_level=2
                ;;
            esac
            prune_job_args+="--verbose=${prune_job_verbosity_level} "
            prune_job_file_log=$(echo "${prune_job_file_log}" ; cat <<EOF
## Verbosity Level:                     ${prune_job_verbosity_level}
EOF
                            )
        fi

        if [ -n "${prune_job_hook_pre}" ]; then
            hook prune pre
        fi

        process_limiter restic 1 prune
        restic_repository=$(mktemp)
        echo "${prune_job_repository_path}" > "${restic_repository}"
        restic \
                --cache-dir "${CACHE_PATH}" \
                --repository-file "${restic_repository}" \
                prune ${prune_job_args} \
                2> /tmp/prune-${prune_routines_start_time}.error \
                > /tmp/prune-${prune_routines_start_time}.log

        exitcode_prune=$?
        rm -rf "${restic_repository}"
        prune_process_finish_time=$(date +%s)
        prune_process_total_time=$(echo $((prune_process_finish_time-prune_process_start_time)))

        case "${exitcode_prune}" in
            0 )
                print_info "[prune] Prune Successful"
                exitcode_prune_description="OK"
            ;;
            1 )
                print_error "[prune] Prune Failed completely"
                exitcode_prune_description="FAIL"
                notify \
                        "$(date -d @"${prune_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}/$(date +'%Y%m%d')/$(date -d @${prune_routines_start_time} +'%Y%m%d_%H%M%S')-prune-${prune_job_log_suffix}.log" \
                        "{exitcode_prune}" \
                        "[FATAL] [${prune_job_log_suffix}] Prune failed completely" \
                        "Restic is failing to prune the '${prune_job_log_suffix}' job."
            ;;
            3 )
                print_error "[prune] Prune completed with errors"
                exitcode_prune_description="ERROR"
                notify \
                        "$(date -d @"${prune_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}/$(date +'%Y%m%d')/$(date -d @${prune_routines_start_time} +'%Y%m%d_%H%M%S')-prune-${prune_job_log_suffix}.log" \
                        "{exitcode_prune}" \
                        "[WARN] [${prune_job_log_suffix}] Prune completed with errors" \
                        "Restic is failing to perform a full prune of the '${prune_job_log_suffix}' job."
            ;;
            * )
                print_error "[prune] Prune Failed with exit_code ${exitcode_prune}"
                exitcode_prune_description="UNKNOWN"
                notify \
                        "$(date -d @"${prune_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}/$(date +'%Y%m%d')/$(date -d @${prune_routines_start_time} +'%Y%m%d_%H%M%S')-prune-${prune_job_log_suffix}.log" \
                        "{exitcode_prune}" \
                        "[WARN] [${prune_job_log_suffix}] Prune failed due to unknown errors" \
                        "Restic is throwing an unknown error code while trying to prune the '${backup_job_log_suffix}' job."
            ;;
        esac

        prune_job_file_log="$(echo "${prune_job_file_log}" ; cat <<EOF

## Prune procedure finished:            $(date -d @${prune_process_finish_time} +'%Y-%m-%d %H:%M:%S') (${prune_process_finish_time})
## Prune procedure total time:          $(echo ${prune_process_total_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${prune_process_total_time})
## Prune procedure completion:          ${exitcode_prune_description} (${exitcode_prune})

### Prune Details
$(cat /tmp/prune-${prune_routines_start_time}.log)

EOF
                        )"

        if [ -s /tmp/prune-"${prune_routines_start_time}".error ] ; then
            prune_job_error_count=$(grep "^error: .*" /tmp/prune-"${prune_routines_start_time}".error | wc -l)
            print_error "${prune_job_error_count} errors detected"
            prune_job_file_log="$(echo "${prune_job_file_log}" ; cat <<EOF
### Error Log
## Errors: ${prune_job_error_count}

$(cat /tmp/prune-${prune_routines_start_time}.error)

EOF
                            )"
        fi
        sudo -u restic mkdir -p "${LOG_PATH}"/"$(date +'%Y%m%d')"
        cat << EOF | silent sudo -u restic tee "${LOG_PATH}"/"$(date +'%Y%m%d')"/"$(date -d @"${prune_process_start_time}" +'%Y%m%d_%H%M%S')"-prune-${prune_job_log_suffix}.log
${prune_job_file_log}

EOF

        cd "${LOG_PATH}"/"$(date +'%Y%m%d')"
        ln -sf "$(date +'%Y%m%d')"/"$(date -d @"${prune_process_start_time}" +'%Y%m%d_%H%M%S')"-prune-"${prune_job_log_suffix}".log ../latest-prune-"${prune_job_log_suffix}".log

        prune_job_packs_reviewed=$(awk '/collecting packs for deletion and repacking/,/packs processed/' /tmp/prune-"${prune_routines_start_time}".log | xargs | awk '{print $11}')
        prune_job_packs_deleted_unreferenced=$(awk '/deleting unreferenced packs/,/files deleted/' /tmp/prune-"${prune_routines_start_time}".log | xargs | awk '{print $8}')
        prune_job_packs_repacked=$(awk '/repacking packs/,/packs processed/' /tmp/prune-"${prune_routines_start_time}".log | xargs | awk '{print $7}')
        prune_job_packs_reindexed=$(awk '/rebuilding index/,/packs processed/' /tmp/prune-"${prune_routines_start_time}".log | xargs | awk '{print $7}')
        prune_job_index_deleted_obsolete=$(awk '/deleting obsolete index files/,/files deleted/' /tmp/prune-"${prune_routines_start_time}".log | xargs | awk '{print $9}')
        prune_job_packs_deleted_old=$(awk '/removing .* old packs/,/files deleted/' /tmp/prune-"${prune_routines_start_time}".log | xargs | awk '{print $9}')

        if var_true "${CONTAINER_ENABLE_MONITORING}" && [ "${CONTAINER_MONITORING_BACKEND,,}" = "zabbix" ]; then
            source /assets/defaults/03-monitoring
            print_notice "Sending Prune Statistics to Zabbix"
            silent zabbix_sender -c /etc/zabbix/zabbix_agentd.conf -k restic.prune -o '[{"{#NAME}":"'${prune_job_log_suffix}'"}]'
            cat <<EOF | silent zabbix_sender -c "${ZABBIX_CONFIG_PATH}"/"${ZABBIX_CONFIG_FILE}" -i -
- restic.prune.start_date.[${prune_job_log_suffix}] "${prune_routines_start_time}"
- restic.prune.status.[${prune_job_log_suffix}] "${exitcode_prune}"
- restic.prune.duration.[${prune_job_log_suffix}] "${prune_process_total_time}"
- restic.prune.packs.reviewed.[${prune_job_log_suffix}] "${prune_job_packs_reviewed}"
- restic.prune.packs.deleted.unreferenced.[${prune_job_log_suffix}] "${prune_job_packs_deleted_unreferenced}"
- restic.prune.packs.repacked.[${prune_job_log_suffix}] "${prune_job_packs_repacked}"
- restic.prune.packs.reindexed.[${prune_job_log_suffix}] "${prune_job_packs_reindexed}"
- restic.prune.index.delete.obsolete.[${prune_job_log_suffix}] "${prune_job_index_deleted_obsolete}"
- restic.prune.packs.deleted.old.[${prune_job_log_suffix}] "${prune_job_packs_deleted_old}"
EOF
        fi

        if [ -n "${prune_job_hook_post}" ]; then
            hook prune post
        fi

        prune_instance_vars=$(mktemp)
        set -o posix ; set | grep -E "^prune_job_" | tr " " "\n" > "${prune_instance_vars}"
        while read -r prune_instance_var ; do
            unset "$(echo "${prune_instance_var}" | cut -d = -f 1)"
        done < "${prune_instance_vars}"
        rm -rf "${prune_instance_vars}"
    }

    server() {
        update_template \
                        /etc/nginx/sites.available/restic-rest-server.conf \
                                                                            SERVER_LISTEN_PORT

        if var_true "${SERVER_ENABLE_AUTHENTICATION}" && [ ! -s "${SERVER_PASSWORD_FILE}" ] ; then
            print_warn "[server] No Users setup in SERVER_PASSWORD_FILE - enter container and use 'server-user create' tool"
            sudo -u restic touch "${SERVER_PASSWORD_FILE}"
        fi

        if [ ! -s "${RCLONE_CONFIG_PATH}"/"${RCLONE_CONFIG_FILE}" ] ; then
            print_warn "[server] Detected missing Rclone configuration file '${RCLONE_CONFIG_PATH}/${RCLONE_CONFIG_FILE}'. Please configure it use the server!"
        fi
    }

    unlock() {
        bootstrap_variables unlock_init $1 $2
        if [ -z "${unlock_routines_start_time}" ] ; then unlock_routines_start_time=$(date +%s) ; fi
            unlock_job_file_log=$(cat <<EOF
## Job Started:                         $(date -d @${unlock_routines_start_time} +'%Y%m%d_%H%M%S') (${unlock_routines_start_time})
## Repository:                          $(echo ${unlock_job_repository_path} | sed "s|\(.*\):\(.*\):.*@\(.*\)|\1:\2:redacted@\3|g")
## Hostname:                            $(hostname)
## Container Name:                      $(echo "${CONTAINER_NAME}")

## Task:                                Unlock
EOF
                       )

        process_limiter restic 1 unlock
        unlock_process_start_time=$(date +%s)
        unlock_job_file_log=$(echo "${unlock_job_file_log}" ; cat <<EOF
## Unlock procedure started:            $(date -d @${unlock_process_start_time} +'%Y-%m-%d %H:%M:%S') (${unlock_process_start_time})
EOF
                        )

        unlock_process_delay_time=$(echo $((unlock_process_start_time-unlock_routines_start_time)))
        if [ "${unlock_process_delay_time}" -ge 5 ] ; then
            unlock_job_file_log=$(echo "${unlock_job_file_log}" ; cat <<EOF
## Delay in starting:                   $(echo ${unlock_routines_delay_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${unlock_process_delay_time})
EOF
                            )
        fi

        if [ -n "${unlock_job_remove_all}" ] ; then
            unlock_job_args+="--remove-all "
            unlock_job_file_log=$(cat ${unlock_job_file_log} ; cat <<EOF
## Unlock Removal Scope:                ALL
EOF
                            )
        fi

        if [ -n "${unlock_job_unlock_args}" ] ; then
            unlock_job_args+="${unlock_job_unlock_args}"
            unlock_job_file_log=$(cat ${unlock_job_file_log} ; cat <<EOF
## Additional Arguments:                ${unlock_job_unlock_args}
EOF
                            )
        fi

        if [ -n "${unlock_job_verbosity_level}" ] ; then
            case "${unlock_job_verbosity_level,,}" in
                0 | normal | standard )
                    unlock_job_verbosity_level=0
                ;;
                1 | verbose )
                    unlock_job_verbosity_level=1
                ;;
                2 | verboseverbose | loud )
                    unlock_job_verbosity_level=2
                ;;
            esac
            unlock_job_args+="--verbose=${unlock_job_verbosity_level} "
            unlock_job_file_log=$(echo "${unlock_job_file_log}" ; cat <<EOF
## Verbosity Level:                     ${unlock_job_verbosity_level}
EOF
                            )
        fi

        if [ -n "${unlock_job_hook_pre}" ]; then
            hook unlock pre
        fi

        restic_repository=$(mktemp)
        echo "${unlock_job_repository_path}" > "${restic_repository}"
        process_limiter restic 1 unlock
        restic \
                --cache-dir "${CACHE_PATH}" \
                --repository-file "${restic_repository}" \
                unlock ${unlock_job_args} \
                2> /tmp/unlock-${unlock_routines_start_time}.error \
                > /tmp/unlock-${unlock_routines_start_time}.log

        exitcode_unlock=$?
        rm -rf "${restic_repository}"
        unlock_process_finish_time=$(date +%s)
        unlock_process_total_time=$(echo $((unlock_process_finish_time-unlock_process_start_time)))

        case "${exitcode_unlock}" in
            0 )
                if [ -s /tmp/unlock-"${unlock_routines_start_time}".error ] || [ -s /tmp/unlock-"${unlock_routines_start_time}".log ] ; then
                    print_info "[unlock] Unlock Successful"
                    exitcode_unlock_description="OK"
                else
                    print_debug "[unlock] Unlock unnecessary"
                    exitcode_unlock_description="NOT_NECESSARY"
                    exitcode_unlock=23
                fi
            ;;
            1 )
                print_error "[unlock] Unlock Failed completely"
                exitcode_unlock_description="FAIL"
                notify \
                        "$(date -d @"${unlock_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}/$(date +'%Y%m%d')/$(date -d @${unlock_routines_start_time} +'%Y%m%d_%H%M%S')-unlock-${unlock_job_log_suffix}.log" \
                        "{exitcode_unlock}" \
                        "[FATAL] [${unlock_job_log_suffix}] Unlock failed completely" \
                        "Restic is failing to unlock the '${unlock_job_log_suffix}' job."
            ;;
            3 )
                print_error "[unlock] Unlock completed with errors"
                exitcode_unlock_description="ERROR"
                notify \
                        "$(date -d @"${unlock_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}/$(date +'%Y%m%d')/$(date -d @${unlock_routines_start_time} +'%Y%m%d_%H%M%S')-unlock-${unlock_job_log_suffix}.log" \
                        "{exitcode_unlock}" \
                        "[WARN] [${unlock_job_log_suffix}] Unlock completed with errors" \
                        "Restic is failing to perform a full unlock of the '${unlock_job_log_suffix}' job."
            ;;
            * )
                print_error "[unlock] Unlock Failed with exit_code ${exitcode_unlock}"
                exitcode_unlock_description="UNKNOWN"
                notify \
                        "$(date -d @"${unlock_routines_start_time}" +'%Y%m%d_%H%M%S')" \
                        "${LOG_PATH}/$(date +'%Y%m%d')/$(date -d @${unlock_routines_start_time} +'%Y%m%d_%H%M%S')-unlock-${unlock_job_log_suffix}.log" \
                        "{exitcode_unlock}" \
                        "[WARN] [${unlock_job_log_suffix}] Unlock failed due to unknown errors" \
                        "Restic is throwing an unknown error code while trying to backup the '${unlock_job_log_suffix}' job."
            ;;
        esac

        unlock_job_file_log=$(echo "${unlock_job_file_log}" ; cat <<EOF

## Unlock procedure finished:           $(date -d @${unlock_process_finish_time} +'%Y-%m-%d %H:%M:%S') (${unlock_process_finish_time})
## Unlock procedure total time:         $(echo ${unlock_process_total_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${unlock_process_total_time})
## Unlock procedure completion:         ${exitcode_unlock_description} (${exitcode_unlock})

### Unlock Details
$(cat /tmp/unlock-${unlock_routines_start_time}.log)

EOF
                        )
        if [ -s /tmp/unlock-"${unlock_routines_start_time}".error ] ; then
            if grep -q "^error: .*" /tmp/unlock-"${unlock_routines_start_time}".error ; then
                unlock_error_count=$(grep "^error: .*" /tmp/unlock-"${unlock_routines_start_time}".error | wc -l)
                print_error "[unlock] ${unlock_error_count} errors detected"
            fi
            unlock_job_file_log=$(echo "${unlock_job_file_log}" ; cat <<EOF

### Error Log
## Errors: ${unlock_error_count}

$(cat /tmp/unlock-${unlock_routines_start_time}.error)


EOF
                            )
        fi

        if [ -s /tmp/unlock-"${unlock_routines_start_time}".error ] || [ -s /tmp/unlock-"${unlock_routines_start_time}".log ] ; then
            sudo -u restic mkdir -p "${LOG_PATH}"/"$(date +'%Y%m%d')"
            cat << EOF | silent sudo -u restic tee "${LOG_PATH}"/"$(date +'%Y%m%d')"/"$(date -d @"${unlock_process_start_time}" +'%Y%m%d_%H%M%S')"-unlock.log
${unlock_job_file_log}

EOF
            cd "${LOG_PATH}"/"$(date +'%Y%m%d')"
            ln -sf "$(date +'%Y%m%d')"/"$(date -d @"${unlock_process_start_time}" +'%Y%m%d_%H%M%S')"-unlock.log ../latest-unlock.log
        fi

        if [ -n "${unlock_job_hook_post}" ]; then
            hook unlock post
        fi

        unset unlock_job_args
        rm -rf /tmp/unlock-"${unlock_routines_start_time}".*
    }

    case "${1}" in
        backup ) backup $2 ;;
        check ) check ;;
        cleanup) cleanup ;;
        init ) init ;;
        inventory ) inventory ;;
        prune ) prune ;;
        server ) server ;;
        unlock ) unlock $2 ;;
    esac
}

process_limiter() {
    process="${1}"
    limiter="${2}"

    while true ; do
        counter=0
        process_amount="$(pidof "${process}" | wc -w)"
        if [ "${process_amount}" -ge "${limiter}" ] ; then
            if [[ "${counter}" =~ 0|45|90|135|180|225|315|360|405|450|495|540|585|630|675|720|765|810|855|900|945|990 ]] ; then
                if [ "${counter}" != 0 ] ; then counter_verbose=" (${counter} seconds so far)" ; fi
                case "${3}" in
                    backup )
                        print_notice "Restic process concurrency liimt reached. Waiting for other tasks to finish before backing up ${counter_verbose}"
                    ;;
                    check )
                        print_notice "Restic is running, waiting for tasks to complete before running a repository check ${counter_verbose}"
                    ;;
                    cleanup )
                        print_notice "Restic is running, waiting for tasks to complete before running a 'forget' task ${counter_verbose}"
                    ;;
                    prune )
                        print_notice "Restic is running, waiting for tasks to complete before running a 'prune' task ${counter_verbose}"
                    ;;
                esac
            fi
            sleep 30
            (( counter+=30))
        else
            break
        fi
    done
}

setup_container_mode() {
    if [ -f "/tmp/.container/toi_restic/CONTAINER_MODE" ]; then
        print_debug "Importing MODE environment generated variables"
        source /tmp/.container/toi_restic/CONTAINER_MODE
    else
        mkdir -p /tmp/.container/toi_restic/
        modes=$(echo "${MODE}" | tr "," "\n")
        for mode in $modes ; do
            case "${mode,,}" in
                "backup" )
                    print_debug "Enabling Container Mode for: BACKUP"
                    echo "ENABLE_BACKUP=TRUE" >> /tmp/.container/toi_restic/CONTAINER_MODE
                ;;
                "check" )
                    print_debug "Enabling Container Mode for: CHECK"
                    echo "ENABLE_CHECK=TRUE" >> /tmp/.container/toi_restic/CONTAINER_MODE
                ;;
                "cleanup" )
                    print_debug "Enabling Container Mode for: CLEANUP"
                    echo "ENABLE_CLEANUP=TRUE" >> /tmp/.container/toi_restic/CONTAINER_MODE
                ;;
                "inventory" )
                    print_debug "Enabling Container Mode for: INVENTORY"
                    echo "ENABLE_INVENTORY=TRUE" >> /tmp/.container/toi_restic/CONTAINER_MODE
                ;;
                "prune" )
                    print_debug "Enabling Container Mode for: PRUNE"
                    echo "ENABLE_PRUNE=TRUE" >> /tmp/.container/toi_restic/CONTAINER_MODE
                ;;
                "server" )
                    print_debug "Enabling Container Mode for: SERVER"
                    echo "ENABLE_SERVER=TRUE" >> /tmp/.container/toi_restic/CONTAINER_MODE
                ;;
                "standalone" | "manual" )
                    print_debug "Enabling Container Mode for: STANDALONE"
                    echo "ENABLE_STANDALONE=TRUE" >> /tmp/.container/toi_restic/CONTAINER_MODE
                ;;
                *)
                    print_error "Unknown 'MODE' environment variable - exitting.."
                    exit 1
                ;;
            esac
        done
        source /tmp/.container/toi_restic/CONTAINER_MODE
    fi
}

