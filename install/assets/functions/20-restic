#!/command/with-contenv bash

bootstrap_filesystem() {
    if [ ! -d "${CONFIG_PATH}" ]; then
        mkdir -p "${CONFIG_PATH}"
    fi
    if [ "$(stat -c %U "${CONFIG_PATH}")" != "restic" ] ; then chown -R restic:restic "${CONFIG_PATH}" ; fi

    if var_true "${ENABLE_SERVER}" && [ "${SERVER_MODE}" != "rclone" ] ; then
        if [ ! -d "${SERVER_REPOSITORY_PATH}" ]; then
            mkdir -p "${SERVER_REPOSITORY_PATH}"
        fi
        if [ "$(stat -c %U "${SERVER_REPOSITORY_PATH}")" != "restic" ] ; then chown restic:restic "${SERVER_REPOSITORY_PATH}" ; fi
    fi

    if [ -d "${REPOSITORY_PATH}" ]; then
        if [ "$(stat -c %U "${REPOSITORY_PATH}")" != "restic" ] ; then chown restic:restic "${REPOSITORY_PATH}" ; fi
    fi

    if var_true "${ENABLE_HOOKS}" ; then
        if [ ! -d "${HOOKS_PATH}" ]; then
            mkdir -p "${HOOKS_PATH}"
        fi
        if [ "$(stat -c %U "${HOOKS_PATH}")" != "restic" ] ; then chown restic:restic "${HOOKS_PATH}" ; fi

        if [ ! -d "${HOOKS_PRE_PATH}" ]; then
            mkdir -p "${HOOKS_PRE_PATH}"
        fi
        if [ "$(stat -c %U "${HOOKS_PRE_PATH}")" != "restic" ] ; then chown restic:restic "${HOOKS_PRE_PATH}" ; fi
        if [ ! -d "${HOOKS_POST_PATH}" ]; then
            mkdir -p "${HOOKS_POST_PATH}"
        fi
        if [ "$(stat -c %U "${HOOKS_POST_PATH}")" != "restic" ] ; then chown restic:restic "${HOOKS_POST_PATH}" ; fi
    fi

    if [ ! -d "${LOG_PATH}" ]; then
        mkdir -p "${LOG_PATH}"
    fi
    if [ "$(stat -c %U "${LOG_PATH}")" != "restic" ] ; then chown -R restic:restic "${LOG_PATH}" ; fi

    case "${LOG_TYPE,,}" in
        file )
            source /assets/defaults/05-logging
            echo "0 0 * * * find ${LOG_PATH} -name \"\$(date --date=\"yesterday\" +\"%Y%m%d\")_*.log\" -print0 | xargs -0 tar cfa ${LOG_PATH}/\$(date --date=\"yesterday\" +\"%Y%m%d\").tar.zst --remove-files  2>/dev/null ; find /logs -name '*.zst' -mtime +${LOGROTATE_REAIN_DAYS}7 -exec rm {} \;" > /assets/cron/restic_log
            if var_true "${ENABLE_SERVER}" ; then
                sudo -u restic touch "${SERVER_LOG_PATH}"/"${SERVER_LOG_FILE}"
                chown restic:restic "${SERVER_LOG_PATH}"/"${SERVER_LOG_FILE}"
                create_logrotate restic-rest-server "${SERVER_LOG_PATH}"/"${SERVER_LOG_FILE}" none restic restic
            fi
        ;;
    esac
}

bootstrap_variables() {
    backup_init() {
        backup_instance_number=${1}
        PROCESS_NAME=backup${backup_instance_number}
        backup_instance_vars=$(mktemp)
        set -o posix ; set | grep -oE "^backup_job_.*=" | tr " " "\n" | grep -oE ".*=" | sed "/--/d" > "${backup_instance_vars}"
        while read -r backup_instance_var ; do
            unset "$(echo "${backup_instance_var}" | cut -d = -f 1)"
        done < "${backup_instance_vars}"

        if [ -v "$(echo BACKUP${backup_instance_number}_REPOSITORY_PASS)" ] && [ "$(set -o posix; set | grep -E "^BACKUP${backup_instance_number}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^BACKUP${backup_instance_number}_REPOSITORY_PASS" | cut -d = -f 2)
        elif [ -n "${DEFAULT_BACKUP_REPOSITORY_PASS}" ] && [ "${DEFAULT_BACKUP_REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD=${DEFAULT_BACKUP_REPOSITORY_PASS}
        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD=${REPOSITORY_PASS}
        fi

        if [ -v "$(echo BACKUP${backup_instance_number}_REPOSITORY_PATH)" ] && [ "$(set -o posix; set | grep -E "^BACKUP${backup_instance_number}_REPOSITORY_PATH" | cut -d = -f 2)" != "unset" ]; then
            export backup_job_repository_path=$(set -o posix; set | grep -E "^BACKUP${backup_instance_number}_REPOSITORY_PATH" | cut -d = -f 2)
        elif [ -n "${DEFAULT_BACKUP_REPOSITORY_PATH}" ] && [ "${DEFAULT_BACKUP_REPOSITORY_PASS}" != "unset" ]; then
            export backup_job_repository_path=${DEFAULT_BACKUP_REPOSITORY_PATH}
        elif [ -n "${REPOSITORY_PATH}" ] && [ "${REPOSITORY_PATH}" != "unset" ]; then
            export backup_job_repository_path=${REPOSITORY_PATH}
        fi

        set -o posix ; set | grep -E "^BACKUP${backup_instance_number}_|^DEFAULT_BACKUP_" | tr " " "\n" > "${backup_instance_vars}"

        transform_backup_instance_variable() {
            if grep -q "^BACKUP${1}_${2}=" "${backup_instance_vars}" && [ "$(grep "^BACKUP${1}_${2}=" "${backup_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^BACKUP${1}_${2}=" "${backup_instance_vars}" | cut -d = -f2)"
            elif grep -q "^DEFAULT_BACKUP_${2}=" "${backup_instance_vars}" && [ "$(grep "^DEFAULT_BACKUP_${2}=" "${backup_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^DEFAULT_BACKUP_${2}=" "${backup_instance_vars}" | cut -d = -f2)"
            fi
        }

        transform_backup_instance_variable "${backup_instance_number}" REPOSITORY_PATH backup_job_respository_path
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_ARGS backup_job_backup_args
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_DRY_RUN backup_job_snapshot_dryrun
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_EXCLUDE backup_job_snapshot_exclude
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_EXCLUDE_FILE backup_job_snapshot_exclude_file
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_NAME backup_job_snapshot_name
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_PATH backup_job_snapshot_path
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_PATH_FILE backup_job_snapshot_path_file
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_TAG backup_job_snapshot_tags
        transform_backup_instance_variable "${backup_instance_number}" SNAPSHOT_VERBOSITY_LEVEL backup_job_snapshot_verbosity_level
        rm -rf "${backup_instance_vars}"
    }

    check_init() {
        check_instance_number=${1}
        PROCESS_NAME=check${check_instance_number}
        check_instance_vars=$(mktemp)
        set -o posix ; set | grep -oE "^check_job_.*=" | tr " " "\n" | grep -oE ".*=" | sed "/--/d" > "${check_instance_vars}"
        while read -r check_instance_var ; do
            unset "$(echo "${check_instance_var}" | cut -d = -f 1)"
        done < "${check_instance_vars}"

        set -o posix ; set | grep -E "^CHECK${check_instance_number}_|^DEFAULT_CHECK_" | tr " " "\n" > "${check_instance_vars}"

        if [ -v "$(echo CHECK${check_instance_number}_REPOSITORY_PASS)" ] && [ "$(set -o posix; set | grep -E "^CHECK${check_instance_number}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^CHECK${check_instance_number}_REPOSITORY_PASS" | cut -d = -f 2)
        elif [ -n "${DEFAULT_CHECK_REPOSITORY_PASS}" ] && [ "${DEFAULT_CHECK_REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD=${DEFAULT_CHECK_REPOSITORY_PASS}
        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD=${REPOSITORY_PASS}
        fi

        transform_check_instance_variable() {
            if grep -q "^CHECK${1}_${2}=" "${check_instance_vars}" && [ "$(grep "^CHECK${1}_${2}=" "${check_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^CHECK${1}_${2}=" "${check_instance_vars}" | cut -d = -f2)"
            elif grep -q "^DEFAULT_CHECK_${2}=" "${check_instance_vars}" && [ "$(grep "^DEFAULT_CHECK_${2}=" "${check_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^DEFAULT_CHECK_${2}=" "${check_instance_vars}" | cut -d = -f2)"
            fi
        }

        transform_check_instance_variable "${check_instance_number}" ARGS check_job_check_args
        transform_check_instance_variable "${check_instance_number}" CHECK_AMOUNT check_job_check_amount
        transform_check_instance_variable "${check_instance_number}" DRY_RUN check_job_check_dryrun
        transform_check_instance_variable "${check_instance_number}" NAME check_job_check_name
        transform_check_instance_variable "${check_instance_number}" REPOSITORY_PASS check_job_repository_pass
        transform_check_instance_variable "${check_instance_number}" REPOSITORY_PATH check_job_repository_path
        transform_check_instance_variable "${check_instance_number}" USE_CACHE check_job_check_use_cache
        transform_check_instance_variable "${check_instance_number}" VERBOSITY_LEVEL check_job_verbosity_level
        rm -rf "${check_instance_vars}"
    }

    cleanup_init() {
        cleanup_instance_number=${1}
        PROCESS_NAME=cleanup${cleanup_instance_number}
        cleanup_instance_vars=$(mktemp)
        set -o posix ; set | grep -oE "^cleanup_job_.*=" | tr " " "\n" | grep -oE ".*=" | sed "/--/d" > "${cleanup_instance_vars}"
        while read -r cleanup_instance_var ; do
            unset "$(echo "${cleanup_instance_var}" | cut -d = -f 1)"
        done < "${cleanup_instance_vars}"

        set -o posix ; set | grep -E "^CLEANUP${cleanup_instance_number}_|^DEFAULT_CLEANUP_" | tr " " "\n" > "${cleanup_instance_vars}"

        if [ -v "$(echo CLEANUP${cleanup_instance_number}_REPOSITORY_PASS)" ] && [ "$(set -o posix; set | grep -E "^CLEANUP${cleanup_instance_number}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^CLEANUP${cleanup_instance_number}_REPOSITORY_PASS" | cut -d = -f 2)
        elif [ -n "${DEFAULT_CLEANUP_REPOSITORY_PASS}" ] && [ "${DEFAULT_CLEANUP_REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD=${DEFAULT_CLEANUP_REPOSITORY_PASS}
        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD=${REPOSITORY_PASS}
        fi

        transform_cleanup_instance_variable() {
            if grep -q "^CLEANUP${1}_${2}=" "${cleanup_instance_vars}" && [ "$(grep "^CLEANUP${1}_${2}=" "${cleanup_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^CLEANUP${1}_${2}=" "${cleanup_instance_vars}" | cut -d = -f2)"
            elif grep -q "^DEFAULT_CLEANUP_${2}=" "${cleanup_instance_vars}" && [ "$(grep "^DEFAULT_CLEANUP_${2}=" "${cleanup_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^DEFAULT_CLEANUP_${2}=" "${cleanup_instance_vars}" | cut -d = -f2)"
            fi
        }

        transform_cleanup_instance_variable "${cleanup_instance_number}" AUTO_PRUNE cleanup_job_auto_prune
        transform_cleanup_instance_variable "${cleanup_instance_number}" ARGS cleanup_job_cleanup_args
        transform_cleanup_instance_variable "${cleanup_instance_number}" DRY_RUN cleanup_job_cleanup_dryrun
        transform_cleanup_instance_variable "${cleanup_instance_number}" NAME cleanup_job_cleanup_name
        transform_cleanup_instance_variable "${cleanup_instance_number}" REPACK cleanup_job_cleanup_repack
        transform_cleanup_instance_variable "${cleanup_instance_number}" REPOSITORY_PASS cleanup_job_repository_pass
        transform_cleanup_instance_variable "${cleanup_instance_number}" REPOSITORY_PATH cleanup_job_repository_path
        transform_cleanup_instance_variable "${cleanup_instance_number}" RETAIN_LAST cleanup_job_retain_last
        transform_cleanup_instance_variable "${cleanup_instance_number}" RETAIN_HOURLY cleanup_job_retain_hourly
        transform_cleanup_instance_variable "${cleanup_instance_number}" RETAIN_DAILY cleanup_job_retain_daily
        transform_cleanup_instance_variable "${cleanup_instance_number}" RETAIN_WEEKLY cleanup_job_retain_weekly
        transform_cleanup_instance_variable "${cleanup_instance_number}" RETAIN_MONTHLY cleanup_job_retain_monthly
        transform_cleanup_instance_variable "${cleanup_instance_number}" RETAIN_YEARLY cleanup_job_retain_yearly
        transform_cleanup_instance_variable "${cleanup_instance_number}" RETAIN_TAGS cleanup_job_retain_tag
        transform_cleanup_instance_variable "${cleanup_instance_number}" VERBOSITY_LEVEL cleanup_job_cleanup_verbosity_level
        rm -rf "${cleanup_instance_vars}"
    }

    prune_init() {
        prune_instance_number=${1}
        PROCESS_NAME=prune${prune_instance_number}
        prune_instance_vars=$(mktemp)
        set -o posix ; set | grep -oE "^prune_job_.*=" | tr " " "\n" | grep -oE ".*=" | sed "/--/d" > "${prune_instance_vars}"
        while read -r prune_instance_var ; do
            unset "$(echo "${prune_instance_var}" | cut -d = -f 1)"
        done < "${prune_instance_vars}"

        if [ -v "$(echo PRUNE${prune_instance_number}_REPOSITORY_PASS)" ] && [ "$(set -o posix; set | grep -E "^PRUNE${prune_instance_number}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^PRUNE${prune_instance_number}_REPOSITORY_PASS" | cut -d = -f 2)
        elif [ -n "${DEFAULT_PRUNE_REPOSITORY_PASS}" ] && [ "${DEFAULT_PRUNE_REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD=${DEFAULT_PRUNE_REPOSITORY_PASS}
        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD=${REPOSITORY_PASS}
        fi

        set -o posix ; set | grep -E "^PRUNE${prune_instance_number}_|^DEFAULT_PRUNE_" | tr " " "\n" > "${prune_instance_vars}"

        transform_prune_instance_variable() {
            if grep -q "^PRUNE${1}_${2}=" "${prune_instance_vars}" && [ "$(grep "^PRUNE${1}_${2}=" "${prune_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^PRUNE${1}_${2}=" "${prune_instance_vars}" | cut -d = -f2)"
            elif grep -q "^DEFAULT_PRUNE_${2}=" "${prune_instance_vars}" && [ "$(grep "^DEFAULT_PRUNE_${2}=" "${prune_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$3"="$(grep "^DEFAULT_PRUNE_${2}=" "${prune_instance_vars}" | cut -d = -f2)"
            fi
        }

        transform_prune_instance_variable "${prune_instance_number}" ARGS prune_job_prune_args
        transform_prune_instance_variable "${prune_instance_number}" DRY_RUN prune_job_prune_dryrun
        transform_prune_instance_variable "${prune_instance_number}" NAME prune_job_prune_name
        transform_prune_instance_variable "${prune_instance_number}" REPOSITORY_PASS prune_job_repository_pass
        transform_prune_instance_variable "${prune_instance_number}" REPOSITORY_PATH prune_job_repository_path
        transform_prune_instance_variable "${prune_instance_number}" VERBOSITY_LEVEL prune_job_verbosity_level
        rm -rf "${prune_instance_vars}"
    }

    unlock_init() {
        unlock_called_from=${1}
        unlock_called_from_instance=${2}
        PROCESS_NAME=unlock
        unlock_instance_vars=$(mktemp)
        set -o posix ; set | grep -oE "^unlock_job_.*=" | tr " " "\n" | grep -oE ".*=" | sed "/--/d" > "${unlock_instance_vars}"
        while read -r unlock_instance_var ; do
            unset "$(echo "${unlock_instance_var}" | cut -d = -f 1)"
        done < "${unlock_instance_vars}"

        if [ -v "$(echo ${unlock_called_from}${unlock_called_from_instance}_REPOSITORY_PASS)" ] && [ "$(set -o posix; set | grep -E "^${unlock_called_from}${unlock_called_from_instance}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^${unlock_called_from}${unlock_called_from_instance}_REPOSITORY_PASS" | cut -d = -f 2)
        elif [ -v $(echo DEFAULT_${unlock_called_from}_REPOSITORY_PASS) ] && [ "$(grep -E "^$(echo DEFAULT_${unlock_called_from}_REPOSITORY_PASS)" | cut -d = -f 2)" != "unset" ] ; then
            export RESTIC_PASSWORD=$(grep -E "^$(echo DEFAULT_${unlock_called_from}_REPOSITORY_PASS)" | cut -d = -f 2)
        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
            export RESTIC_PASSWORD=${REPOSITORY_PASS}
        fi

        if [ -v "$(echo ${unlock_called_from}${unlock_called_from_instance}_REPOSITORY_PATH)" ] && [ "$(set -o posix; set | grep -E "^${unlock_called_from}${unlock_called_from_instance}_REPOSITORY_PATH" | cut -d = -f 2)" != "unset" ]; then
            export unlock_job_repository_path=$(set -o posix; set | grep -E "^${unlock_called_from}${unlock_called_from_instance}_REPOSITORY_PATH" | cut -d = -f 2)
        elif [ -v $(echo DEFAULT_${unlock_called_from}_REPOSITORY_PATH) ] && [ "$(grep -E "^$(echo DEFAULT_${unlock_called_from}_REPOSITORY_PATH)" | cut -d = -f 2)" != "unset" ] ; then
            export unlock_job_repository_path=$(grep -E "^$(echo DEFAULT_${unlock_called_from}_REPOSITORY_PATH)" | cut -d = -f 2)
        elif [ -n "${REPOSITORY_PATH}" ] && [ "${REPOSITORY_PATH}" != "unset" ]; then
            export unlock_job_repository_path=${REPOSITORY_PATH}
        fi

        set -o posix ; set | grep -E "^UNLOCK_|^DEFAULT_UNLOCK_" | tr " " "\n" > "${unlock_instance_vars}"

        transform_unlock_variable() {
            if grep -q "^UNLOCK_${1}=" "${unlock_instance_vars}" && [ "$(grep "^UNLOCK_${1}=" "${unlock_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$2"="$(grep "^UNLOCK_${1}=" "${unlock_instance_vars}" | cut -d = -f2)"
            elif grep -q "^DEFAULT_UNLOCK_${1}=" "${unlock_instance_vars}" && [ "$(grep "^DEFAULT_UNLOCK_${1}=" "${unlock_instance_vars}" | cut -d = -f2)" != "unset" ]; then
                export "$2"="$(grep "^DEFAULT_UNLOCK_${1}=" "${unlock_instance_vars}" | cut -d = -f2)"
            fi
        }

        transform_unlock_variable ARGS unlock_job_unlock_args
        transform_unlock_variable REMOVE_ALL unlock_job_remove_all
        transform_unlock_variable VERBOSITY_LEVEL unlock_job_verbosity_level

        rm -rf "${unlock_instance_vars}"
    }

    upgrade_lonely_variables() {
        upgrade_lonely_variables_tmp=$(mktemp)
        set -o posix; set | grep "^$1" | grep -v "^$1[0-9]._" > "${upgrade_lonely_variables_tmp}"
        while read -r exist_var ; do
            if [ ! -v "$1"01_"$(echo "${exist_var}" | cut -d = -f1 | cut -d _ -f2)" ] ; then
                export "$1"01_"$(echo "${exist_var}" | cut -d = -f1 | cut -d _ -f2-9)"="$(echo "${exist_var}" | cut -d = -f2)"
            else
                print_error "Variable $101_$(echo "${exist_var}" | cut -d = -f1 | cut -d _ -f2) already exists, fix your variables and start again.."
                exit 1
            fi
        done < "${upgrade_lonely_variables_tmp}"
        rm -rf "${upgrade_lonely_variables_tmp}"
    }

    case "${1}" in
        backup_init ) backup_init "$2" ;;
        check_init ) check_init "$2" ;;
        cleanup_init ) cleanup_init "$2" ;;
        prune_init ) prune_init "$2" ;;
        unlock_init ) unlock_init "$2" "$3" ;;
        upgrade ) upgrade_lonely_variables "$2" ;;
    esac
}


create_schedulers() {
    backup() {
        bootstrap_variables upgrade BACKUP
        local backup_instances=$(printenv | sort | grep -c "^BACKUP[0-9]._SNAPSHOT_PATH")
        for (( instance = 01; instance <= backup_instances; instance++ )) ; do
            instance=$(printf "%02d" $instance)
            if [ -v BACKUP${instance}_REPOSITORY_PATH ] && [ "$(set -o posix; set | grep -E "^BACKUP${instance}_REPOSITORY_PATH" | cut -d = -f 2)" != "unset" ]; then
                echo "BACKUP${instance} $(grep -E "^BACKUP${instance}_REPOSITORY_PATH" | cut -d = -f 2)" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            elif [ -n "${DEFAULT_BACKUP_REPOSITORY_PATH}" ] && [ "${DEFAULT_BACKUP_REPOSITORY_PATH}" != "unset" ]; then
                echo "BACKUP${instance} ${DEFAULT_BACKUP_REPOSITORY_PATH}" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            elif [ -n "${REPOSITORY_PATH}" ] && [ "${REPOSITORY_PATH}" != "unset" ]; then
                echo "BACKUP${instance} ${REPOSITORY_PATH}" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            fi

            cp -R /assets/restic/template-restic-backup /etc/services.available/restic-backup"${instance}"
            sed -i "s|{{BACKUP_NUMBER}}|${instance}|g" /etc/services.available/restic-backup"${instance}"/run
            cat <<EOF >> /usr/bin/backup"${instance}"-now
#!/bin/bash
source /assets/functions/00-container
PROCESS_NAME=backup${instance}
print_info "Starting Manual Backup for BACKUP${instance}"
/var/run/s6/legacy-services/restic-backup${instance}/run now

EOF
            chmod +x /usr/bin/backup"${instance}"-now
            if [ "${instance}" = "01" ] ; then
                touch /usr/bin/backup-now
                chmod +x /usr/bin/backup-now
                cat <<EOF > /usr/bin/backup-now
#!/bin/bash

/usr/bin/backup${instance}-now

EOF
            else
                echo "/usr/bin/backup${instance}-now" >> /usr/bin/backup-now
            fi
        done
    }

    check() {
        bootstrap_variables upgrade CHECK
        check_instances=$(set -o posix ; set | sort | grep -Ec "^CHECK[0-9]._REPOSITORY_PATH")
        for (( instance = 01; instance <= check_instances; instance++ )) ; do
            instance=$(printf "%02d" $instance)

            if [ -v CHECK${instance}_REPOSITORY_PATH ] && [ "$(set -o posix; set | grep -E "^CHECK${instance}_REPOSITORY_PATH" | cut -d = -f 2)" != "unset" ]; then
                echo "CHECK${instance} $(set -o posix; set | grep -E "^CHECK${instance}_REPOSITORY_PATH" | cut -d = -f 2)" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            elif [ -n "${DEFAULT_CHECK_REPOSITORY_PATH}" ] && [ "${DEFAULT_CHECK_REPOSITORY_PATH}" != "unset" ]; then
                echo "CHECK${instance} ${DEFAULT_CHECK_REPOSITORY_PATH}" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            fi

            cp -R /assets/restic/template-restic-check /etc/services.available/restic-check"${instance}"
            sed -i "s|{{CHECK_NUMBER}}|${instance}|g" /etc/services.available/restic-check"${instance}"/run

        cat <<EOF >> /usr/bin/check"${instance}"-now
#!/bin/bash
source /assets/functions/00-container
PROCESS_NAME=check${instance}
print_info "Starting Manual Check for for CHECK${instance}"
/var/run/s6/legacy-services/restic-check${instance}/run now

EOF
            chmod +x /usr/bin/check"${instance}"-now
            if [ "${instance}" = "01" ] ; then
                touch /usr/bin/check-now
                chmod +x /usr/bin/check-now
                cat <<EOF > /usr/bin/check-now
#!/bin/bash

/usr/bin/check${instance}-now

EOF
            else
                echo "/usr/bin/check${instance}-now" >> /usr/bin/check-now
            fi
        done
    }

    cleanup() {
        bootstrap_variables upgrade CLEANUP
        cleanup_instances=$(set -o posix ; set | sort | grep -Ec "^CLEANUP[0-9]._REPOSITORY_PATH")
        for (( instance = 01; instance <= cleanup_instances; instance++ )) ; do
            instance=$(printf "%02d" $instance)

            if [ -v CLEANUP${instance}_REPOSITORY_PATH ] && [ "$(set -o posix; set | grep -E "^CLEANUP${instance}_REPOSITORY_PATH" | cut -d = -f 2)" != "unset" ]; then
                echo "CLEANUP${instance} $(set -o posix; set | grep -E "^CLEANUP${instance}_REPOSITORY_PATH" | cut -d = -f 2)" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            elif [ -n "${DEFAULT_CLEANUP_REPOSITORY_PATH}" ] && [ "${DEFAULT_CLEANUP_REPOSITORY_PATH}" != "unset" ]; then
                echo "CLEANUP${instance} ${DEFAULT_CLEANUP_REPOSITORY_PATH}" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            fi

            cp -R /assets/restic/template-restic-cleanup /etc/services.available/restic-cleanup"${instance}"
            sed -i "s|{{CLEANUP_NUMBER}}|${instance}|g" /etc/services.available/restic-cleanup"${instance}"/run

        cat <<EOF >> /usr/bin/cleanup"${instance}"-now
#!/bin/bash
source /assets/functions/00-container
PROCESS_NAME=cleanup${instance}
print_info "Starting Manual Check for for CLEANUP${instance}"
/var/run/s6/legacy-services/restic-cleanup${instance}/run now

EOF
            chmod +x /usr/bin/cleanup"${instance}"-now
            if [ "${instance}" = "01" ] ; then
                touch /usr/bin/cleanup-now
                chmod +x /usr/bin/cleanup-now
                cat <<EOF > /usr/bin/cleanup-now
#!/bin/bash

/usr/bin/cleanup${instance}-now

EOF
            else
                echo "/usr/bin/cleanup${instance}-now" >> /usr/bin/cleanup-now
            fi
        done
    }

    init() {
        if [ -f "/tmp/.container/toi_restic/INIT_REPOSITORIES" ]; then
            print_debug "Creating init repositories routine"
            touch /tmp/.container/toi_restic/INIT_REPOSITORIES
            sort -t ' ' -k2 -u /tmp/.container/toi_restic/INIT_REPOSITORIES -o /tmp/.container/toi_restic/INIT_REPOSITORIES
        fi

        cp -R /assets/restic/template-restic-initialize_repository /etc/services.available/restic-initialize_repository
    }

    prune() {
        bootstrap_variables upgrade PRUNE
        local prune_instances=$(set -o posix; set | sort | grep -Ec "^PRUNE[0-9.]+_REPOSITORY_PATH")
        for (( instance = 01; instance <= prune_instances; instance++ )) ; do
            instance=$(printf "%02d" $instance)

            if [ -v PRUNE${instance}_REPOSITORY_PATH ] && [ "$(set -o posix; set | grep -E "^PRUNE${instance}_REPOSITORY_PATH" | cut -d = -f 2)" != "unset" ]; then
                echo "PRUNE${instance} $(set -o posix; set | grep -E "^PRUNE${instance}_REPOSITORY_PATH" | cut -d = -f 2)" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            elif [ -n "${DEFAULT_PRUNE_REPOSITORY_PATH}" ] && [ "${DEFAULT_PRUNE_REPOSITORY_PATH}" != "unset" ]; then
                echo "PRUNE${instance} ${DEFAULT_PRUNE_REPOSITORY_PATH}" >> /tmp/.container/toi_restic/INIT_REPOSITORIES
            fi

            cp -R /assets/restic/template-restic-prune /etc/services.available/restic-prune"${instance}"
            sed -i "s|{{PRUNE_NUMBER}}|${instance}|g" /etc/services.available/restic-prune"${instance}"/run

            cat <<EOF >> /usr/bin/prune"${instance}"-now
#!/bin/bash
source /assets/functions/00-container
PROCESS_NAME=prune${instance}
print_info "Starting Manual Prune for PRUNE${instance}"
/var/run/s6/legacy-services/restic-prune${instance}/run now

EOF
            chmod +x /usr/bin/prune"${instance}"-now
            if [ "${instance}" = "01" ] ; then
                touch /usr/bin/prune-now
                chmod +x /usr/bin/prune-now
                cat <<EOF > /usr/bin/prune-now
#!/bin/bash

/usr/bin/prune${instance}-now

EOF
            else
                echo "/usr/bin/prune${instance}-now" >> /usr/bin/prune-now
            fi
        done
    }

    case "${1}" in
        backup ) backup ;;
        check ) check ;;
        cleanup) cleanup ;;
        init ) init ;;
        prune ) prune ;;
    esac
}

repository() {
    backup() {
        process_limiter restic "${BACKUP_JOB_CONCURRENCY}" backup
        backup_process_start_time=$(date +%s)
        backup_job_file_log=$(cat <<EOF
# Job Started:                          $(date -d @"${backup_routines_start_time}" +"%Y%m%d_%H%M%S") (${backup_routines_start_time})
# Repository:                           $(echo "${backup_job_repository_path}" | sed "s|\(.*\):\(.*\):.*@\(.*\)|\1:\2:redacted@\3|g")
# Hostname:                             $(hostname)
# Container Name:                       $(echo "${CONTAINER_NAME}")

## Task:                                Backup (${backup_instance_number})
EOF
                        )
        if [ -n "${backup_job_snapshot_name}" ] ; then
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup Name:                         ${backup_job_snapshot_name}
EOF
                            )
        fi
        if [ -n "${backup_job_snapshot_path}" ] ; then
        backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup Path:                         ${backup_job_snapshot_path}
EOF
                        )
        fi
        if [ -n "${backup_job_snapshot_path_file}" ] ; then
        backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup Path File:                    ${backup_job_backup_file}
EOF
                        )
        fi

        backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup procedure started:            $(date -d @"${backup_process_start_time}" +"%Y-%m-%d %H:%M:%S") (${backup_process_start_time})
EOF
                        )
        backup_process_delay_time=$(echo $((backup_process_start_time-backup_routines_start_time)))
        if [ "${backup_process_delay_time}" -ge 5 ] ; then
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Delay in starting:                   $(echo "${backup_process_delay_time}" | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${backup_process_delay_time})
EOF
                            )
        fi

        if [ -n "${backup_job_snapshot_exclude}" ] ; then
            backup_job_snapshot_excludes=$(echo "${backup_job_snapshot_exclude}" | sed "s|'||g" | tr "," "\n")
            for exclude in ${backup_job_snapshot_excludes} ; do
                backup_job_args+="--exclude ${exclude} "
            done
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup Exclude:                      $(echo "${backup_job_snapshot_exclude}" | sed "s|'||g" )
EOF
                            )
        fi

        if [ -n "${backup_job_snapshot_exclude_file}" ] ; then
            if [ -f "${backup_job_snapshot_exclude_file}" ]; then
                backup_job_args+="--exclude_file ${BACKUP_EXCLUDE_FILE} "
                backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup Exclude File:                ${BACKUP_EXCLUDE_FILE}"
EOF
                                )
            else
                print_error "Cannot find EXCLUDE_FILE '${backup_job_snapshot_exclude_file}'"
                backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup Exclude File:                ERROR: Set but missing: ${BACKUP_EXCLUDE_FILE}
EOF
                                )

            fi
        fi

        if var_true "${backup_job_snapshot_dryrun}" ; then
            print_notice "DRY_RUN enabled - No backups will actually be written!"
            backup_job_args+="--dry-run "
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Dry Run enabled - No backups were actually performed"
EOF
                            )
        fi

        if [ -n "${backup_job_backup_args}" ] ; then
            backup_job_args+="${backup_job_backup_args} "
            backup_job_file_log=$(cat <<EOF
## Additional Arguments:                ${backup_job_backup_args}
EOF
                            )
        fi

        if [ -n "${backup_job_snapshot_path_file}" ] ; then
            backup_job_args+="-files-from ${backup_job_snapshot_path_file} "
        fi

        if [ -n "${backup_job_snapshot_verbosity_level}" ] ; then
            case "${backup_job_snapshot_verbosity_level,,}" in
                0 | normal | standard )
                    backup_job_snapshot_verbosity_level=0
                ;;
                1 | verbose )
                    backup_job_snapshot_verbosity_level=1
                ;;
                2 | verboseverbose | loud )
                    backup_job_snapshot_verbosity_level=2
                ;;
            esac
            backup_job_args+="--verbose=${backup_job_snapshot_verbosity_level} "
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Verbosity Level:                     ${backup_job_snapshot_verbosity_level}
EOF
                            )
        fi

        if [ -n "${backup_job_snapshot_name}" ] ; then
            backup_job_args+="--tag ${backup_job_snapshot_name} "
            backup_job_log_suffix=${backup_job_snapshot_name,,}
        else
            backup_job_log_suffix=${backup_instance_number}
        fi

        if [ -n "${backup_job_snapshot_path}" ] ; then
            backup_job_args+="${backup_job_snapshot_path} "
        fi

        if [ -n "${backup_job_snapshot_tags}" ] ; then
            backup_snapshot_tags=$(echo "${backup_job_snapshot_tags}" | tr "," "\n")
            for backup_snapshot_tag in ${backup_snapshot_job_tags} ; do
                backup_job_arg+="--tag ${backup_snapshot_tag} "
            done
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup Tags added:                  ${backup_job_snapshot_tags}
EOF
                                )
        fi

        if [ -n "${backup_job_snapshot_tags}" ] ; then
            backup_job_args+="${backup_job_snapshot_path} "
        fi

        if var_true "${DEBUG_MODE}" || [ ${CONTAINER_LOG_LEVEL,,} = "debug" ]; then
            command_string="restic --repo ${backup_job_repository_path} backup --host ${CONTAINER_NAME} --tag auto ${backup_args} ${backup_job_snapshot_path}"
            print_debug "Command execution string: '${command_string}'"
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Debug Command String:               ${command_string}
EOF
                            )
        fi

        print_info "Starting Backup Snapshot ${backup_job_log_suffix}"
        restic \
                --repo "${backup_job_repository_path}" \
                backup \
                    --host "${CONTAINER_NAME}" ${backup_job_args} \
                    --tag auto \
                2> /tmp/"${backup_instance_number}"-backup-${backup_routines_start_time}.error \
                > /tmp/${backup_instance_number}-backup-${backup_routines_start_time}.log
        exitcode_backup=$?
        backup_process_finish_time=$(date +%s)
        backup_process_total_time=$(echo $((backup_process_finish_time-backup_routines_start_time)))

        case "${exitcode_backup}" in
            0 )
                print_info "Backup Successful"
                exitcode_backup_description="OK"
            ;;
            1 )
                exitcode_backup_description="FAIL"
                backup_job_error_log=true
                if grep -q "^Fatal: .*" /tmp/"${backup_instance_number}"-backup-"${backup_routines_start_time}".error ; then
                    backup_fatal_error="- Fatal errors detected"
                fi
                print_error "Backup Failed completely ${backup_fatal_error}"
                backup_job_error_log=true
            ;;
            3 )
                exitcode_backup_description="ERROR"
                if grep -q "^error: .*" /tmp/"${backup_instance_number}"-backup-"${backup_routines_start_time}".error ; then
                    backup_error_count=$(grep -c "^error: .*" /tmp/"${backup_number}"-"${backup_routines_start_time}".error)
                fi
                backup_error_description="#### Error Count: ${backup_error_count}"
                print_error "Backup completed with ${backup_error_count} errors detected"
                backup_job_error_log=true
            ;;
            130 )
                print_error "Backup Failed due to user cancellation"
                exitcode_backup_description="CANCELLED"
                backup_job_error_log=true
            ;;
            * )
                print_error "Backup Failed with exit code ${exitcode_backup}"
                exitcode_backup_description="UNKNOWN"
                backup_job_error_log=true
            ;;
        esac

        backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF
## Backup procedure finished:           $(date -d @${backup_process_finish_time} +"%Y-%m-%d %H:%M:%S") (${backup_process_finish_time})
## Backup procedure total time:         $(echo ${backup_process_total_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${backup_process_total_time})
## Backup procedure completion:         ${exitcode_backup_description} (${exitcode_backup})

### Backup Details
$(cat /tmp/"${backup_instance_number}"-backup-"${backup_routines_start_time}".log | sed "/^unchanged/d" )

EOF
                        )

        if var_true "${backup_job_error_log}" ; then
            backup_job_file_log=$(echo "${backup_job_file_log}" ; cat <<EOF

#### Error Log
${backup_error_description}
${backup_error_description}

$(cat /tmp/${backup_instance_number}-backup-${backup_routines_start_time}.error)

EOF
                            )
        fi

        cat << EOF | silent sudo -u restic tee "${LOG_PATH}"/"$(date -d @"${backup_process_start_time}" +"%Y%m%d_%H%M%S")"-backup-${backup_job_log_suffix}.log
${backup_job_file_log}

EOF

        backup_job_backup_summary_files=$(grep "^Files:" /tmp/${backup_instance_number}-backup-${backup_routines_start_time}.log | xargs | sed "s|Files:||g")
        print_debug "[summary] Backup Summary Files: ${backup_job_backup_summary_files}"
        backup_job_backup_summary_files_new=$(echo "${backup_job_backup_summary_files}" | awk '{print $1}')
        print_debug "[summary] Files new: ${backup_job_backup_summary_files_new}"
        backup_job_backup_summary_files_changed=$(echo "${backup_job_backup_summary_files}" | awk '{print $3}')
        print_debug "[summary] Files changed: ${backup_job_backup_summary_files_changed}"
        backup_job_backup_summary_files_unmodified=$(echo "${backup_job_backup_summary_files}" | awk '{print $5}')
        print_debug "[summary] Files unmodified: ${backup_job_backup_summary_files_unmodified}"
        backup_job_backup_summary_directory=$(grep "^Dirs:" /tmp/${backup_instance_number}-backup-${backup_routines_start_time}.log | xargs | sed "s|Dirs:||g")
        print_debug "[summary] Backup_summary_directory: ${backup_job_backup_summary_directory}"
        backup_job_backup_summary_directory_new=$(echo "${backup_job_backup_summary_directory}" | awk '{print $1}')
        print_debug "[summary] Directory new: ${backup_job_backup_summary_directory_new}"
        backup_job_backup_summary_directory_changed=$(echo "${backup_job_backup_summary_directory}" | awk '{print $3}')
        print_debug "[summary] Directory changed: ${backup_job_backup_summary_directory_changed}"
        backup_job_backup_summary_directory_unmodified=$(echo "${backup_job_backup_summary_directory}" | awk '{print $5}')
        print_debug "[summary] Directory unmodified: ${backup_job_backup_summary_directory_unmodified}"
        backup_job_backup_summary_added=$(grep "^Added to the repository:" /tmp/${backup_instance_number}-backup-${backup_routines_start_time}.log | xargs | sed "s|Added to the repository:||g" | tr "," "\n")
        print_debug "[summary] Backup_summary added: ${backup_job_backup_summary_added}"
        backup_job_backup_summary_added_size_bytes=$(echo "${backup_job_backup_summary_added}" | awk '{print$1 $2}')
        if [ "${backup_job_backup_summary_added_size_bytes}" = "0B" ] ; then
            backup_job_backup_summary_added_size_bytes=0
        else
            backup_job_backup_summary_added_size_bytes=$(echo "${backup_job_backup_summary_added}" | awk '{print$1 $2}' | numfmt --from=iec-i --to=none --suffix=B 2>/dev/null| sed "s|B$||g")
        fi
        print_debug "[summary] added size bytes: ${backup_job_backup_summary_added_size_bytes}"
        backup_job_backup_summary_added_size_stored_bytes=$(echo "${backup_job_backup_summary_added}" | awk '{print$3 $4}' | sed -e "s|(||g" -e "s|)||g" )
        if [ "${backup_job_backup_summary_added_size_stored_bytes}" = "0B" ] ; then
            backup_job_backup_summary_added_size_stored_bytes=0
        else
            backup_job_backup_summary_added_size_stored_bytes=$(echo "${backup_job_backup_summary_added}" | awk '{print$3 $4}' | sed -e "s|(||g" -e "s|)||g" | numfmt --from=iec-i --to=none --suffix=B 2>/dev/null| sed "s|B$||g")
        fi
        print_debug "[summary] Added size stored bytes: ${backup_job_backup_summary_added_size_stored_bytes}"
        backup_job_backup_summary_processed=$(grep "^processed" /tmp/${backup_instance_number}-backup-${backup_routines_start_time}.log | sed "s|processed||g" )
        print_debug "[summary] Backup_summary processed: ${backup_job_backup_summary_processed}"
        backup_job_backup_summary_proccessed_files=$(echo "${backup_job_backup_summary_processed}" | awk '{print $1}')
        print_debug "[summary] Processed files: ${backup_job_backup_summary_proccessed_files}"
        backup_job_backup_summary_processed_size_bytes=$(echo "${backup_job_backup_summary_processed}" | awk '{print $3 $4}')
        if [ "${backup_job_backup_summary_processed_size_bytes}" = "0B" ] ; then
            backup_job_backup_summary_processed_size_bytes=0
        else
            backup_job_backup_summary_processed_size_bytes=$(echo "${backup_job_backup_summary_processed}" | awk '{print $3 $4}' | numfmt --from=iec-i --to=none --suffix=B 2>/dev/null | sed "s|B$||g")
        fi
        print_debug "[summary] Processed size bytes: ${backup_job_backup_summary_processed_size_bytes}"
        rm -rf /tmp/${backup_instance_number}-backup-${backup_routines_start_time}.*

        PROCESS_NAME=post_backup${backup_instance_number}
        if var_true "${CONTAINER_ENABLE_MONITORING}" && [ "${CONTAINER_MONITORING_BACKEND,,}" = "zabbix" ]; then
            source /assets/defaults/03-monitoring
            print_notice "Sending Backup Statistics to Zabbix"
            silent zabbix_sender -c /etc/zabbix/zabbix_agentd.conf -k restic.backup -o '[{"{#NAME}":"'${backup_job_log_suffix}'"}]'
            cat <<EOF | silent zabbix_sender -c "${ZABBIX_CONFIG_PATH}"/"${ZABBIX_CONFIG_FILE}" -i -
- restic.backup.start_date.[${backup_job_log_suffix}] "${backup_routines_start_time}"
- restic.backup.status.[${backup_job_log_suffix}] "${exitcode_backup}"
- restic.backup.backup.duration.[${backup_job_log_suffix}] "${backup_process_total_time}"
- restic.backup.files.new.[${backup_job_log_suffix}] "${backup_job_backup_summary_files_new}"
- restic.backup.files.changed.[${backup_job_log_suffix}] "${backup_job_backup_summary_files_changed}"
- restic.backup.files.unmodified.[${backup_job_log_suffix}] "${backup_job_backup_summary_files_unmodified}"
- restic.backup.dirs.new.[${backup_job_log_suffix}] "${backup_job_backup_summary_directory_new}"
- restic.backup.dirs.changed.[${backup_job_log_suffix}] "${backup_job_backup_summary_directory_changed}"
- restic.backup.dirs.unmodified.[${backup_job_log_suffix}] "${backup_job_backup_summary_directory_unmodified}"
- restic.backup.size.bytes.added.[${backup_job_log_suffix}] "${backup_job_backup_summary_added_size_bytes}"
- restic.backup.size.bytes.stored.[${backup_job_log_suffix}] "${backup_job_backup_summary_added_size_stored_bytes}"
- restic.backup.size.bytes.processed.[${backup_job_log_suffix}] "${backup_job_backup_summary_processed_size_bytes}"
EOF
        fi

        backup_instance_vars=$(mktemp)
        set -o posix ; set | grep -oE "^backup_job_.*=" | tr " " "\n"| grep -oE ".*=" | sed "/--/d" > "${backup_instance_vars}"
        while read -r backup_instance_var ; do
            unset "$(echo "${backup_instance_var}" | cut -d = -f 1)"
        done < "${backup_instance_vars}"
        rm -rf "${backup_instance_vars}"
    }

    check() {
        if [ -z "${check_routines_start_time}" ] ; then check_routines_start_time=$(date +%s) ; fi
        check_job_file_log=$(cat <<EOF
## Job Started:                         $(date -d @${check_routines_start_time} +"%Y%m%d_%H%M%S") (${check_routines_start_time})
## Repository:                          $(echo ${check_job_repository_path} | sed "s|\(.*\):\(.*\):.*@\(.*\)|\1:\2:redacted@\3|g")
## Hostname:                            $(hostname)
## Container Name:                      $(echo "${CONTAINER_NAME}")

## Task:                                Check
EOF
                        )

        process_limiter restic 1 check
        check_process_start_time=$(date +%s)
        check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF
## Check procedure started:             $(date -d @${check_process_start_time} +"%Y-%m-%d %H:%M:%S") (${check_process_start_time})
EOF
                        )

        check_process_delay_time=$(echo $((check_process_start_time-check_routines_start_time)))
        if [ "${check_process_delay_time}" -ge 5 ] ; then
            check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF
## Delay in starting:                   $(echo ${check_routines_delay_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${check_process_delay_time})"
EOF
                            )
        fi

        if [ -n "${check_job_check_name}" ] ; then
            check_job_log_suffix="${check_job_check_name,,}"
        else
            check_job_log_suffix="${check_instance_number}"
        fi

        if [ -n "${check_job_check_use_cache}" ] ; then
            if var_true "${check_job_check_use_cache}" ; then
                check_job_args+="--with-cache "
            fi
            check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF
## Cache Enabled:                       ${check_job_check_use_cache}
EOF
                            )
        fi

        if [ -n "${check_job_check_amount}" ] ; then
            if [ "${check_job_check_amount}" = "all" ] ; then
                check_job_args+="--read-data "
                check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF
## Checking data:                       ALL
EOF
                                )
            else
                check_job_args+="--read-data-subset ${check_job_check_amount} "
                check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF
## Checking data:                       SUBSET ${check_job_check_amount}
EOF
                                )
            fi
        fi

        if [ -n "${check_job_check_args}" ] ; then
            check_job_args+="${check_job_check_args}"
            check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF
## Additional Arguments:                ${check_job_check_args}
EOF
                            )
        fi

        if var_true "${check_job_check_dryrun}" ; then
            print_notice "DRY_RUN enabled - No checks will actually be performed!"
            check_job_args+="--dry-run "
            check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF
## Dry Run enabled - No checks were actually performed"
EOF
                            )
        fi

        if [ -n "${check_job_verbosity_level}" ] ; then
            case "${check_job_verbosity_level,,}" in
                0 | normal | standard )
                    check_job_verbosity_level=0
                ;;
                1 | verbose )
                    check_job_verbosity_level=1
                ;;
                2 | verboseverbose | loud )
                    check_job_verbosity_level=2
                ;;
            esac
            check_job_args+="--verbose=${check_job_verbosity_level} "
            check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF
## Verbosity Level:                     ${check_job_verbosity_level}
EOF
                            )
        fi

        process_limiter restic 1 check
        restic \
                -r "${check_job_repository_path}" \
                check ${check_job_args} \
                2> /tmp/check-${check_routines_start_time}.error \
                > /tmp/check-${check_routines_start_time}.log

        exitcode_check=$?

        check_process_finish_time=$(date +%s)
        check_process_total_time=$(echo $((check_process_finish_time-check_process_start_time)))
        case "${exitcode_check}" in
            0 )
                print_info "[check] Check Successful"
                exitcode_check_description="OK"
            ;;
            1 )
                print_error "[check] Check Failed completely"
                exitcode_check_description="FAIL"
            ;;
            3 )
                print_error "[check] Check completed with errors"
                exitcode_check_description="ERROR"
            ;;
            * )
                print_error "[check] Check Failed with exit_code ${exitcode_check}"
                exitcode_check_description="UNKNOWN"
            ;;
        esac

        check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF

## Check procedure finished:            $(date -d @${check_process_finish_time} +"%Y-%m-%d %H:%M:%S") (${check_process_finish_time})
## Check procedure total time:          $(echo ${check_process_total_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${check_process_total_time})
## Check procedure completion:          ${exitcode_check_description} (${exitcode_check})

### Check Details
$(cat /tmp/check-${check_routines_start_time}.log)

EOF
                        )

        if [ -s /tmp/check-"${check_routines_start_time}".error ] ; then
            if grep -q "^error: .*" /tmp/check-"${check_routines_start_time}".error ; then
                check_job_error_count=$(grep "^error: .*" /tmp/check-"${check_routines_start_time}".error | wc -l)
                print_error "[check] ${check_job_error_count} errors detected"
            fi
            check_job_file_log=$(echo "${check_job_file_log}" ; cat <<EOF

### Error Log
## Errors: ${check_job_error_count}

$(cat /tmp/check-${check_routines_start_time}.error)


EOF
                            )
        fi

        cat << EOF | silent sudo -u restic tee "${LOG_PATH}"/"$(date -d @"${check_process_start_time}" +"%Y%m%d_%H%M%S")"-check-"${check_job_log_suffix}".log
${check_job_file_log}

EOF

        PROCESS_NAME=post_check${check_instance_number}
        if var_true "${CONTAINER_ENABLE_MONITORING}" && [ "${CONTAINER_MONITORING_BACKEND,,}" = "zabbix" ]; then
            source /assets/defaults/03-monitoring
            print_notice "Sending Check Statistics to Zabbix"
            silent zabbix_sender -c /etc/zabbix/zabbix_agentd.conf -k restic.check -o '[{"{#NAME}":"'${check_job_log_suffix}'"}]'
            cat <<EOF | silent zabbix_sender -c "${ZABBIX_CONFIG_PATH}"/"${ZABBIX_CONFIG_FILE}" -i -
- restic.check.start_date.[${check_job_log_suffix}] "${check_routines_start_time}"
- restic.check.status.[${check_job_log_suffix}] "${exitcode_check}"
- restic.check.duration.[${check_job_log_suffix}] "${check_process_total_time}"
EOF
        fi

        check_instance_vars=$(mktemp)
        set -o posix ; set | grep -oE "^check_job_.*=" | tr " " "\n" | grep -oE ".*=" | sed "/--/d" > "${check_instance_vars}"
        while read -r check_instance_var ; do
            unset "$(echo "${check_instance_var}" | cut -d = -f 1)"
        done < "${check_instance_vars}"
        rm -rf "${check_instance_vars}"
    }

    cleanup() {
        if [ -z "${cleanup_routines_start_time}" ] ; then cleanup_routines_start_time=$(date +%s) ; fi
            cleanup_job_file_log=$(cat <<EOF
## Job Started:                        $(date -d @${cleanup_routines_start_time} +"%Y%m%d_%H%M%S") (${cleanup_routines_start_time})
## Repository:                         $(echo ${cleanup_job_repository_path} | sed "s|\(.*\):\(.*\):.*@\(.*\)|\1:\2:redacted@\3|g")
## Hostname:                           $(hostname)
## Container Name:                     $(echo "${CONTAINER_NAME}")

## Task:                               Cleanup
EOF
                            )

            process_limiter restic 1 cleanup
            cleanup_process_start_time=$(date +%s)
            cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Cleanup procedure started:          $(date -d @${cleanup_process_start_time} +"%Y-%m-%d %H:%M:%S") (${cleanup_process_start_time})
EOF
                            )
            cleanup_process_delay_time=$(echo $((cleanup_process_finish_time-cleanup_process_start_time)))
            if [ "${cleanup_process_delay_time}" -ge "5" ] ; then
                cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Delay in starting:                   $(echo ${cleanup_process_delay_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${check_process_delay_time})
EOF
                                )
            fi

            if [ -n "${cleanup_job_cleanup_name}" ] ; then
                cleanup_job_log_suffix=${cleanup_job_cleanup_name,,}
            else
                cleanup_job_log_suffix=${cleanup_instance_number}
            fi

            if [ -n "${cleanup_job_retain_last}" ] ; then
                cleanup_job_keep_arg+="--keep-last ${cleanup_job_retain_last} "
                cleanup_job_log_keep_policy="${cleanup_job_retain_last} last "
            fi
            if [ -n "${cleanup_job_retain_hourly}" ] ; then
                cleanup_job_keep_arg+="--keep-hourly ${cleanup_job_retain_hourly} "
                cleanup_job_log_keep_policy+="${cleanup_job_retain_hourly} hourly "
            fi
            if [ -n "${cleanup_job_retain_daily}" ] ; then
                cleanup_job_keep_arg+="--keep-daily ${cleanup_job_retain_daily} "
                cleanup_job_log_keep_policy+="${cleanup_job_retain_daily} daily "
            fi
            if [ -n "${cleanup_job_retain_weekly}" ] ; then
                cleanup_job_keep_arg+="--keep-weekly ${cleanup_job_retain_weekly} "
                cleanup_job_log_keep_policy+="${cleanup_job_retain_weekly} weekly "
            fi
            if [ -n "${cleanup_job_retain_monthly}" ] ; then
                cleanup_job_keep_arg+="--keep-monthly ${cleanup_job_retain_monthly} "
                cleanup_job_log_keep_policy+="${cleanup_job_retain_monthly} monthly "
            fi
            if [ -n "${cleanup_job_retain_yearly}" ] ; then
                cleanup_job_keep_arg+="--keep-yearly ${cleanup_job_retain_yearly} "
                cleanup_job_log_keep_policy+="${cleanup_job_retain_yearly} yearly"
            fi

            if [ -n "${cleanup_job_retain_tag}" ] ; then
                cleanup_retain_tags=$(echo "${cleanup_job_retain_tag}" | tr "," "\n")
                for cleanup_retain_tag in ${cleanup_retain_tags} ; do
                    cleanup_job_keep_arg+="--keep-tag ${cleanup_retain_tag}"
                done
            fi

            if [ -n "${cleanup_job_log_keep_policy}" ] ; then
                cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Cleanup Policy:                     ${cleanup_job_log_keep_policy}
EOF
                                    )
            fi

            if [ -n "${cleanup_job_log_retain_tag}" ] ; then
                cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
cleanup_job_log_retain_tag="## Skipping tags:                      ${cleanup_job_retain_tag}
EOF
                                )
            fi

            if [ -n "${cleanup_job_keep_arg}" ] ; then
                cleanup_job_args+=${cleanup_job_keep_arg}
            fi

            case "${cleanup_job_cleanup_repack}" in
                cacheable )
                    cleanup_job_args+="--repack-cacheable-only "
                    cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Repack                              Cacheable Only
EOF
                                        )
                ;;
                small )
                    cleanup_job_args+="--repack-small "
                    cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Repack                              Cacheable Only
EOF
                                        )
                ;;
                uncompressed )
                    cleanup_job_args+="--repack-uncompressed "
                    cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Repack                              Uncompressed
EOF
                                        )
                ;;
                none )
                    cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Repack                              None
EOF
                                        )
                ;;
            esac

            if var_true "${cleanup_job_auto_prune}" ; then
                print_notice "AUTO_PRUNE enabled - Will prune after successful cleanup"
                cleanup_job_args+="--prune "
                cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Auto Prune                          Enabled
EOF
                                )
            fi

            if var_true "${cleanup_job_cleanup_dryrun}" ; then
                print_notice "DRY_RUN enabled - No cleanup will actually be performed!"
                cleanup_job_args+="--dry-run "
                cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Dry Run enabled - No cleanup was actually performed
EOF
                                )
            fi

            if [ -n "${cleanup_job_cleanup_args}" ] ; then
                cleanup_job_args+="${cleanup_job_cleanup_args} "
                cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Additional Arguments:                ${cleanup_job_cleanup_args}
EOF
                                )
            fi

            if [ -n "${cleanup_job_cleanup_verbosity_level}" ] ; then
                case "${cleanup_job_cleanup_verbosity_level,,}" in
                    0 | normal | standard )
                        cleanup_job_cleanup_verbosity_level=0
                    ;;
                    1 | verbose )
                        cleanup_job_cleanup_verbosity_level=1
                    ;;
                    2 | verboseverbose | loud )
                        cleanup_job_cleanup_verbosity_level=2
                    ;;
                esac
                cleanup_job_args+="--verbose=${cleanup_job_cleanup_verbosity_level} "
                cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Verbosity Level:                    ${cleanup_job_cleanup_verbosity_level}
EOF
                                )
            fi

            if var_true "${DEBUG_MODE}" || [ ${CONTAINER_LOG_LEVEL,,} = "debug" ]; then
                cleanup_command_string="restic --repo ${cleanup_job_repository_path} forget --host ${CONTAINER_NAME} --group-by '' ${cleanup_job_args}"
                print_debug "Command execution string: '${cleanup_command_string}'"
                cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Debug Command String:               ${cleanup_command_string}
EOF
                                )
            fi

            print_info "Starting cleanup of old backups"
            restic \
                    -r "${cleanup_job_repository_path}" \
                    forget \
                            --host "${CONTAINER_NAME}" \
                            --group-by '' ${cleanup_job_args} \
                            2> /tmp/"${cleanup_instance_number}"-cleanup-"${cleanup_routines_start_time}".error \
                            > /tmp/"${cleanup_instance_number}"-cleanup-"${cleanup_routines_start_time}".log

            exitcode_cleanup="$?"

            cleanup_process_finish_time="$(date +%s)"
            cleanup_process_total_time="$(echo $((cleanup_process_finish_time-cleanup_routines_start_time)))"

            case "${exitcode_cleanup}" in
                0 )
                    print_info "[cleanup] Cleanup successful"
                    exitcode_cleanup_description="OK"
                ;;
                1 )
                    print_error "[cleanup] Cleanup failed completely"
                    exitcode_cleanup_description="FAIL"
                ;;
                3 )
                    print_error "[cleanup] Cleanup completed with errors"
                    exitcode_cleanup_description="ERROR"
                ;;
                130 )
                    print_error "[cleanup] Cleanup failed due to user cancellation"
                    exitcode_cleanup_description="CANCELLED"
                ;;
                * )
                    print_error "[cleanup] Cleanup Failed with exit_code ${exitcode_cleanup}"
                    exitcode_cleanup_description="UNKNOWN"
                ;;
            esac

            cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF
## Cleanup procedure finished:         $(date -d @${cleanup_process_finish_time} +"%Y-%m-%d %H:%M:%S") (${cleanup_process_finish_time})
## Cleanup procedure total time:       $(echo ${cleanup_routines_total_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${cleanup_process_total_time})
## Cleanup procedure completion:       ${exitcode_cleanup_description} (${exitcode_cleanup})

### Cleanup Details
$(cat /tmp/${cleanup_instance_number}-cleanup-${cleanup_routines_start_time}.log)

EOF
                            )

        if [ -s /tmp/${cleanup_instance_number}-cleanup-${cleanup_routines_start_time}.error ] ; then
            if grep -q "^error: .*" /tmp/${cleanup_instance_number}-cleanup-"${cleanup_routines_start_time}".error ; then
                cleanup_job_error_count=$(grep "^error: .*" /tmp/${cleanup_instance_number}-cleanup-${cleanup_routines_start_time}.error | wc -l)
                print_error "[Cleanup] ${cleanup_job_error_count} errors detected"
            fi
            cleanup_job_file_log=$(echo "${cleanup_job_file_log}" ; cat <<EOF

### Error Log
## Errors: ${cleanup_job_error_count}

$(cat /tmp/${cleanup_instance_number}-cleanup-${cleanup_routines_start_time}.error)

EOF
                            )
        fi

        rm -rf /tmp/"${cleanup_instance_number}"-cleanup-"${cleanup_routines_start_time}".*
        cat << EOF | silent sudo -u restic tee -a "${LOG_PATH}"/"$(date -d @"${cleanup_process_start_time}" +"%Y%m%d_%H%M%S")"-cleanup-${cleanup_job_log_suffix}.log
${cleanup_job_file_log}
EOF

        PROCESS_NAME=post_cleanup${cleanup_instance_number}
        if var_true "${CONTAINER_ENABLE_MONITORING}" && [ "${CONTAINER_MONITORING_BACKEND,,}" = "zabbix" ]; then
            source /assets/defaults/03-monitoring
            print_notice "Sending Cleanup Statistics to Zabbix"
            silent zabbix_sender -c /etc/zabbix/zabbix_agentd.conf -k restic.cleanup -o '[{"{#NAME}":"'${cleanup_job_log_suffix}'"}]'
            cat <<EOF | silent zabbix_sender -c "${ZABBIX_CONFIG_PATH}"/"${ZABBIX_CONFIG_FILE}" -i -
- restic.cleanup.start_date.[${cleanup_job_log_suffix}] "${prune_routines_start_time}"
- restic.cleanup.status.[${cleanup_job_log_suffix}] "${exitcode_cleanup}"
- restic.cleanup.duration.[${cleanup_job_log_suffix}] "${cleanup_process_total_time}"
EOF
        fi

        cleanup_instance_vars=$(mktemp)
        set -o posix ; set | grep -oE "^cleanup_job_.*=" | tr " " "\n" | grep -oE ".*=" | sed "/--/d" > "${cleanup_instance_vars}"

        while read -r cleanup_instance_var ; do
            print_debug "Unsetting '$(echo "${cleanup_instance_var}" | cut -d = -f 1)'"
            unset "$(echo "${cleanup_instance_var}" | cut -d = -f 1)"
        done < "${cleanup_instance_vars}"
        rm -rf "${cleanup_instance_vars}"
    }

    init() {
        while read -r repository_to_init ; do
            if [ -v $(echo "${repository_to_init}" | awk '{print $1}')_SKIP_INIT ] && [ "$(set -o posix; set | grep -E "^${repository_to_init}_SKIP_INIT" | cut -d = -f 2)" = "TRUE" ]; then
                skip_init=true
            elif [ -n "${DEFAULT_SKIP_INIT}" ] && [ "${DEFAULT_SKIP_INIT}" != "true" ]; then
                skip_init=true
            elif [ -n "${SKIP_INIT}" ] && [ "${SKIP_INIT}" != "true" ]; then
                skip_init=true
            fi

            if var_nottrue "${skip_init}" ; then
                print_debug "Initializing Repository: ${repository_to_init}"
                if grep -q "ENABLE_SERVER=TRUE" /tmp/.container/toi_restic/CONTAINER_MODE ; then
                    print_notice "Delaying Initialization Routines until REST Server is running"
                    wait_for_port 127.0.0.1 "${SERVER_LISTEN_PORT}"
                elif [ -v "$(echo "${repository_to_init}" | awk '{print $1}')"_DELAY_INIT ] && [ "$(set -o posix; set | grep -E "^${repository_to_init}_DELAY_INIT" | cut -d = -f 2)" != "unset" ]; then
                    delay_init=$(set -o posix; set | grep -E "^${repository_to_init}_DELAY_INIT" | cut -d = -f 2)
                elif [ -n "${DEFAULT_DELAY_INIT}" ] && [ "${DEFAULT_DELAY_INIT}" != "unset" ]; then
                    delay_init=${DEFAULT_DELAY_INIT}
                elif [ -n "${DELAY_INIT}" ] && [ "${DELAY_INIT}" != "unset" ]; then
                    delay_init=${DELAY_INIT}
                fi

                if [ -n "${delay_init}" ] ; then
                    print_notice "Delaying repository initialization of $(echo ${repository_to_init} | awk '{print $1}') for ${delay_init} seconds"
                    sleep "${delay_init}"
                fi

                case "$(echo "${repository_to_init}" | awk '{print $1}')" in
                    BACKUP* )
                        if [ "$(echo ${repository_to_init} | awk '{print $1}')" = "BACKUP01" ] ; then bootstrap_variables upgrade BACKUP ; fi
                        if [ -v "$(echo ${repository_to_init} | awk '{print $1}')"_REPOSITORY_PASS ] && [ "$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
                            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)
                        elif [ -n "${DEFAULT_BACKUP_REPOSITORY_PASS}" ] && [ "${DEFAULT_BACKUP_REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${DEFAULT_BACKUP_REPOSITORY_PASS}
                        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${REPOSITORY_PASS}
                        fi
                    ;;
                    CHECK* )
                        if [ "$(echo ${repository_to_init} | awk '{print $1}')" = "CHECK01" ] ; then bootstrap_variables upgrade CHECK ; fi
                        if [ -v "$(echo "${repository_to_init}" | awk '{print $1}')"_REPOSITORY_PASS ] && [ "$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
                            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)
                        elif [ -n "${DEFAULT_CHECK_REPOSITORY_PASS}" ] && [ "${DEFAULT_CHECK_REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${DEFAULT_CHECK_REPOSITORY_PASS}
                        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${REPOSITORY_PASS}
                        fi
                    ;;
                    CLEANUP* )
                        if [ "$(echo ${repository_to_init} | awk '{print $1}')" = "CLEANUP01" ] ; then bootstrap_variables upgrade CLEANUP ; fi
                        if [ -v "$(echo "${repository_to_init}" | awk '{print $1}')"_REPOSITORY_PASS ] && [ "$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
                            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)
                        elif [ -n "${DEFAULT_CLEANUP_REPOSITORY_PASS}" ] && [ "${DEFAULT_CLEANUP_REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${DEFAULT_CLEANUP_REPOSITORY_PASS}
                        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${REPOSITORY_PASS}
                        fi
                    ;;
                    PRUNE* )
                        if [ "$(echo "${repository_to_init}" | awk '{print $1}')" = "PRUNE01" ] ; then bootstrap_variables upgrade PRUNE ; fi
                        if [ -v "$(echo ${repository_to_init} | awk '{print $1}')"_REPOSITORY_PASS ] && [ "$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)" != "unset" ]; then
                            export RESTIC_PASSWORD=$(set -o posix; set | grep -E "^${repository_to_init}_REPOSITORY_PASS" | cut -d = -f 2)
                        elif [ -n "${DEFAULT_PRUNE_REPOSITORY_PASS}" ] && [ "${DEFAULT_PRUNE_REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${DEFAULT_PRUNE_REPOSITORY_PASS}
                        elif [ -n "${REPOSITORY_PASS}" ] && [ "${REPOSITORY_PASS}" != "unset" ]; then
                            export RESTIC_PASSWORD=${REPOSITORY_PASS}
                        fi

                    ;;
                esac

                if [ -v "$(echo "${repository_to_init}" | awk '{print $1}')"_INIT_ARGS ] && [ "$(set -o posix; set | grep -E "^${repository_to_init}_INIT_ARGS" | cut -d = -f 2)" != "unset" ]; then
                    repository_init_arg=$(set -o posix; set | grep -E "^${repository_to_init}_INIT_ARGS" | cut -d = -f 2)
                elif [ -n "${DEFAULT_INIT_ARGS}" ] && [ "${DEFAULT_INIT_ARGS}" != "unset" ]; then
                    repository_init_arg=${DEFAULT_INIT_ARGS}
                fi

                silent restic \
                                -r "$(echo "${repository_to_init}" | awk '{print $2}')" \
                                snapshots \
                                --host "${CONTAINER_NAME}" \
                                --quiet ${repository_init_arg}
                exitcode_init=$?
                print_debug "[check_init_repository] [${repository_to_init}] Check exit code ${init_status}"

                if [ "${exitcode_init}" != "0" ]; then
                    print_debug "[check_repository] No repository found"
                    print_notice "[check_repository] Initializing Repository '$(echo "${repository_to_init}" | awk '{print $1}')'"
                    silent restic \
                                    -r "$(echo "${repository_to_init}" | awk '{print $2}')" \
                                    init ${repository_init_arg}
                    exitcode_init=$?

                    if [ "${exitcode_init}" != 0 ]; then
                        print_error "Failed to init the repository: '$(echo "${repository_to_init}" | awk '{print $1}')':"
                        restic \
                            -r "$(echo "${repository_to_init}" | awk '{print $2}')" \
                            init ${repository_init_arg}
                        return "${exitcode_init}"
                    else
                        return "${exitcode_init}"
                    fi
                else
                    return "${exitcode_init}"
                fi
            else
                print_debug "Skipped Initialization routines for '$(echo "${repository_to_init}" | awk '{print $1}')'"
                exitcode_init=0
                return 0
            fi
        done < "/tmp/.container/toi_restic/INIT_REPOSITORIES"
    }

    prune() {
        if [ -z "${prune_routines_start_time}" ] ; then prune_routines_start_time=$(date +%s) ; fi
        prune_job_file_log=$(cat <<EOF
## Job Started:                         $(date -d @${prune_routines_start_time} +"%Y%m%d_%H%M%S") (${prune_routines_start_time})
## Repository:                          $(echo ${prune_job_repository_path} | sed "s|\(.*\):\(.*\):.*@\(.*\)|\1:\2:redacted@\3|g")
## Hostname:                            $(hostname)
## Container Name:                      $(echo ${CONTAINER_NAME})

## Task:                                Prune
EOF
                        )

        process_limiter restic 1 prune
        prune_process_start_time=$(date +%s)
        prune_job_file_log=$(echo "${prune_job_file_log}" ; cat <<EOF
## Prune procedure started:             $(date -d @${prune_process_start_time} +"%Y-%m-%d %H:%M:%S") (${prune_process_start_time})
EOF
                        )

        prune_process_delay_time=$(echo $((prune_process_start_time-prune_routines_start_time)))
        if [ "${prune_process_delay_time}" -ge 5 ] ; then
            prune_job_file_log=$(echo "${prune_job_file_log}" ; cat <<EOF
## Delay in starting:                   $(echo ${prune_routines_delay_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${prune_process_delay_time})
EOF
                        )
        fi

        if [ -n "${prune_job_check_name}" ] ; then
            prune_job_log_suffix=${prune_job_prune_name,,}
        else
            prune_job_log_suffix=${prune_instance_number}
        fi

        if [ -n "${prune_job_check_args}" ] ; then
            prune_job_args+="${prune_job_prune_args}"
            prune_job_file_log=$(echo "${prune_job_file_log}" ; cat <<EOF
## Additional Arguments:                ${prune_job_prune_args}
EOF
                            )
        fi

        if var_true "${prune_job_prune_dryrun}" ; then
            print_notice "DRY_RUN enabled - No pruning will actually be performed!"
            prune_job_args+="--dry-run "
            prune_job_file_log=$(echo "${prunes_file_log}" ; cat <<EOF
## Dry Run enabled - No prunes were actually performed"
EOF
                            )
        fi

        if [ -n "${prune_job_verbosity_level}" ] ; then
            case "${prune_job_verbosity_level,,}" in
                0 | normal | standard )
                    prune_job_verbosity_level=0
                ;;
                1 | verbose )
                    prune_job_verbosity_level=1
                ;;
                2 | verboseverbose | loud )
                    prune_job_verbosity_level=2
                ;;
            esac
            prune_job_args+="--verbose=${prune_job_verbosity_level} "
            prune_job_file_log=$(echo "${prune_job_file_log}" ; cat <<EOF
## Verbosity Level:                     ${prune_job_verbosity_level}
EOF
                            )
        fi

        process_limiter restic 1 prune
        restic \
                -r "${prune_job_repository_path}" \
                prune ${prune_job_args} \
                2> /tmp/prune-${prune_routines_start_time}.error \
                > /tmp/prune-${prune_routines_start_time}.log

        exitcode_prune=$?

        prune_process_finish_time=$(date +%s)
        prune_process_total_time=$(echo $((prune_process_finish_time-prune_process_start_time)))
        case "${exitcode_prune}" in
            0 )
                print_info "[prune] Prune Successful"
                exitcode_prune_description="OK"
            ;;
            1 )
                print_error "[prune] Prune Failed completely"
                exitcode_prune_description="FAIL"
            ;;
            3 )
                print_error "[prune] Prune completed with errors"
                exitcode_prune_description="ERROR"
            ;;
            * )
                print_error "[prune] Prune Failed with exit_code ${exitcode_prune}"
                exitcode_prune_description="UNKNOWN"
            ;;
        esac

        prune_job_file_log="$(echo "${prune_job_file_log}" ; cat <<EOF

## Prune procedure finished:            $(date -d @${prune_process_finish_time} +"%Y-%m-%d %H:%M:%S") (${prune_process_finish_time})
## Prune procedure total time:          $(echo ${prune_process_total_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${prune_process_total_time})
## Prune procedure completion:          ${exitcode_prune_description} (${exitcode_prune})

### Prune Details
$(cat /tmp/prune-${prune_routines_start_time}.log)

EOF
                        )"

## TOI TODO Prune Sample Log
# loading indexes...
# loading all snapshots...
# finding data that is still in use for 203 snapshots
# [0:59] 100.00%  203 / 203 snapshots
#
# searching used packs...
# collecting packs for deletion and repacking
# [0:01] 100.00%  680 / 680 packs processed
#
#
# to repack:         77467 blobs / 2.046 GiB
# this removes:      19044 blobs / 651.923 MiB
# to delete:         57205 blobs / 2.126 GiB
# total prune:       76249 blobs / 2.762 GiB
# remaining:        493297 blobs / 3.527 GiB
# unused size after prune: 0 B (0.00% of remaining size)
#
# deleting unreferenced packs
# [0:05] 100.00%  38 / 38 files deleted
#
# repacking packs
# [2:37] 100.00%  336 / 336 packs repacked
#
# rebuilding index
# [0:02] 100.00%  330 / 330 packs processed
#
# deleting obsolete index files
# [0:22] 100.00%  199 / 199 files deleted
#
# removing 438 old packs
# [0:48] 100.00%  438 / 438 files deleted
#
# done


        if [ -s /tmp/prune-"${prune_routines_start_time}".error ] ; then
            ## TOI Lock Checking TODO
##
##Fatal: unable to create lock in backend: repository is already locked by PID 1548 on ecc8da8681d1 by root (UID 0, GID 0)
##lock was created at 2023-02-06 18:46:23 (114h14m37.154670174s ago)
##storage ID 3214de91



            prune_job_error_count=$(grep "^error: .*" /tmp/prune-"${prune_routines_start_time}".error | wc -l)
            print_error "${prune_job_error_count} errors detected"
            prune_job_file_log="$(echo "${prune_job_file_log}" ; cat <<EOF
### Error Log
## Errors: ${prune_job_error_count}

$(cat /tmp/prune-${prune_routines_start_time}.error)

EOF
                            )"
        fi

        cat << EOF | silent sudo -u restic tee "${LOG_PATH}"/"$(date -d @"${prune_process_start_time}" +"%Y%m%d_%H%M%S")"-prune-${prune_job_log_suffix}.log
${prune_job_file_log}

EOF

        PROCESS_NAME=post_prune${prune_instance_number}
        if var_true "${CONTAINER_ENABLE_MONITORING}" && [ "${CONTAINER_MONITORING_BACKEND,,}" = "zabbix" ]; then
            source /assets/defaults/03-monitoring
            print_notice "Sending Prune Statistics to Zabbix"
            silent zabbix_sender -c /etc/zabbix/zabbix_agentd.conf -k restic.prune -o '[{"{#NAME}":"'${prune_job_log_suffix}'"}]'
            cat <<EOF | silent zabbix_sender -c "${ZABBIX_CONFIG_PATH}"/"${ZABBIX_CONFIG_FILE}" -i -
- restic.prune.start_date.[${prune_job_log_suffix}] "${prune_routines_start_time}"
- restic.prune.status.[${prune_job_log_suffix}] "${exitcode_prune}"
- restic.prune.duration.[${prune_job_log_suffix}] "${prune_process_total_time}"
EOF
        fi

        prune_instance_vars=$(mktemp)
        set -o posix ; set | grep -E "^prune_job_" | tr " " "\n" > "${prune_instance_vars}"
        while read -r prune_instance_var ; do
            unset "$(echo "${prune_instance_var}" | cut -d = -f 1)"
        done < "${prune_instance_vars}"
        rm -rf "${prune_instance_vars}"
    }

    server() {
        update_template \
                        /etc/nginx/sites.available/restic-rest-server.conf \
                                                                            SERVER_LISTEN_PORT

        if var_true "${SERVER_ENABLE_AUTHENTICATION}" && [ ! -s "${SERVER_PASSWORD_FILE}" ] ; then
            print_warn "[server] No Users setup in SERVER_PASSWORD_FILE - enter container and use 'server-user create' tool"
            sudo -u restic touch "${SERVER_PASSWORD_FILE}"
        fi

        if [ ! -s "${RCLONE_CONFIG_PATH}"/"${RCLONE_CONFIG_FILE}" ] ; then
            print_warn "[server] Detected missing Rclone configuration file '${RCLONE_CONFIG_PATH}/${RCLONE_CONFIG_FILE}'. Please configure it use the server!"
        fi
    }

    unlock() {
        bootstrap_variables unlock_init $1 $2
        if [ -z "${unlock_routines_start_time}" ] ; then unlock_routines_start_time=$(date +%s) ; fi
            unlock_job_file_log=$(cat <<EOF
## Job Started:                         $(date -d @${unlock_routines_start_time} +"%Y%m%d_%H%M%S") (${unlock_routines_start_time})
## Repository:                          $(echo ${unlock_job_repository_path} | sed "s|\(.*\):\(.*\):.*@\(.*\)|\1:\2:redacted@\3|g")
## Hostname:                            $(hostname)
## Container Name:                      $(echo "${CONTAINER_NAME}")

## Task:                                Unlock
EOF
                       )

        process_limiter restic 1 unlock
        unlock_process_start_time=$(date +%s)
        unlock_job_file_log=$(echo "${unlock_job_file_log}" ; cat <<EOF
## Unlock procedure started:            $(date -d @${unlock_process_start_time} +"%Y-%m-%d %H:%M:%S") (${unlock_process_start_time})
EOF
                        )

        unlock_process_delay_time=$(echo $((unlock_process_start_time-unlock_routines_start_time)))
        if [ "${unlock_process_delay_time}" -ge 5 ] ; then
            unlock_job_file_log=$(echo "${unlock_job_file_log}" ; cat <<EOF
## Delay in starting:                   $(echo ${unlock_routines_delay_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${unlock_process_delay_time})"
EOF
                            )
        fi

        if [ -n "${unlock_job_remove_all}" ] ; then
            unlock_job_args+="--remove-all "
            unlock_job_file_log=$(cat ${unlock_job_file_log} ; cat <<EOF
## Unlock Removal Scope:                ALL
EOF
                            )
        fi

        if [ -n "${unlock_job_unlock_args}" ] ; then
            unlock_job_args+="${unlock_job_unlock_args}"
            unlock_job_file_log=$(cat ${unlock_job_file_log} ; cat <<EOF
## Additional Arguments:                ${unlock_job_unlock_args}
EOF
                            )
        fi

        if [ -n "${unlock_job_verbosity_level}" ] ; then
            case "${unlock_job_verbosity_level,,}" in
                0 | normal | standard )
                    unlock_job_verbosity_level=0
                ;;
                1 | verbose )
                    unlock_job_verbosity_level=1
                ;;
                2 | verboseverbose | loud )
                    unlock_job_verbosity_level=2
                ;;
            esac
            unlock_job_args+="--verbose=${unlock_job_verbosity_level} "
            unlock_job_file_log=$(echo "${unlock_job_file_log}" ; cat <<EOF
## Verbosity Level:                     ${unlock_job_verbosity_level}
EOF
                            )
        fi

        process_limiter restic 1 unlock
        restic \
                -r "${unlock_job_repository_path}" \
                unlock ${unlock_job_args} \
                2> /tmp/unlock-${unlock_routines_start_time}.error \
                > /tmp/unlock-${unlock_routines_start_time}.log

        exitcode_unlock=$?

        unlock_process_finish_time=$(date +%s)
        unlock_process_total_time=$(echo $((unlock_process_finish_time-unlock_process_start_time)))
        case "${exitcode_unlock}" in
            0 )
                if [ -s /tmp/unlock-"${unlock_routines_start_time}".error ] || [ -s /tmp/unlock-"${unlock_routines_start_time}".log ] ; then
                    print_info "[unlock] Unlock Successful"
                    exitcode_unlock_description="OK"
                else
                    print_debug "[unlock] Unlock unnecessary"
                    exitcode_unlock_description="NOT_NECESSARY"
                    exitcode_unlock=23
                fi
            ;;
            1 )
                print_error "[unlock] Unlock Failed completely"
                exitcode_unlock_description="FAIL"
            ;;
            3 )
                print_error "[unlock] Unlock completed with errors"
                exitcode_unlock_description="ERROR"
            ;;
            * )
                print_error "[unlock] Unlock Failed with exit_code ${exitcode_unlock}"
                exitcode_unlock_description="UNKNOWN"
            ;;
        esac

        unlock_job_file_log=$(echo "${unlock_job_file_log}" ; cat <<EOF

## Unlock procedure finished:           $(date -d @${unlock_process_finish_time} +"%Y-%m-%d %H:%M:%S") (${unlock_process_finish_time})
## Unlock procedure total time:         $(echo ${unlock_process_total_time} | awk '{printf "%dh%02dm%02ds", $1/3600, ($1/60)%60, $1%60}') (${unlock_process_total_time})
## Unlock procedure completion:         ${exitcode_unlock_description} (${exitcode_unlock})

### Unlock Details
$(cat /tmp/unlock-${unlock_routines_start_time}.log)

EOF
                        )
        ## TOI Lock detection required and restart after first fail based on env
        if [ -s /tmp/unlock-"${unlock_routines_start_time}".error ] ; then
            if grep -q "^error: .*" /tmp/unlock-"${unlock_routines_start_time}".error ; then
                unlock_error_count=$(grep "^error: .*" /tmp/unlock-"${unlock_routines_start_time}".error | wc -l)
                print_error "[unlock] ${unlock_error_count} errors detected"
            fi
            unlock_job_file_log=$(echo "${unlock_job_file_log}" ; cat <<EOF

### Error Log
## Errors: ${unlock_error_count}

$(cat /tmp/unlock-${unlock_routines_start_time}.error)


EOF
                            )
        fi

        if [ -s /tmp/unlock-"${unlock_routines_start_time}".error ] || [ -s /tmp/unlock-"${unlock_routines_start_time}".log ] ; then
            cat << EOF | silent sudo -u restic tee "${LOG_PATH}"/"$(date -d @"${unlock_process_start_time}" +"%Y%m%d_%H%M%S")"-unlock.log
${unlock_job_file_log}

EOF
        fi

        unset unlock_job_args
        rm -rf /tmp/unlock-"${unlock_routines_start_time}".*
    }

    case "${1}" in
        backup ) backup $2 ;;
        check ) check ;;
        cleanup) cleanup ;;
        init ) init ;;
        prune ) prune ;;
        server ) server ;;
        unlock ) unlock $2 ;;
    esac
}

process_limiter() {
    process="${1}"
    limiter="${2}"

    while true ; do
        counter=0
        process_amount=$(pidof ${process} | wc -w)
        if [ "${process_amount}" -ge "${limiter}" ] ; then
            if [[ "${counter}" =~ 0|45|90|135|180|225|315|360|405|450|495|540|585|630|675|720|765|810|855|900|945|990 ]] ; then
                if [ "${counter}" != 0 ] ; then counter_verbose=" (${counter} seconds so far)" ; fi
                case "${3}" in
                    backup )
                        print_notice "Restic process concurrency liimt reached. Waiting for other tasks to finish before backing up ${counter_verbose}"
                    ;;
                    check )
                        print_notice "Restic is running, waiting for tasks to complete before running a repository check ${counter_verbose}"
                    ;;
                    cleanup )
                        print_notice "Restic is running, waiting for tasks to complete before running a 'forget' task ${counter_verbose}"
                    ;;
                    prune )
                        print_notice "Restic is running, waiting for tasks to complete before running a 'prune' task ${counter_verbose}"
                    ;;
                esac
            fi
            sleep 15
        else
            break
        fi
    done
}

post_backup() {
    :
}

setup_container_mode() {
    if [ -f "/tmp/.container/restic/CONTAINER_MODE" ]; then
        print_debug "Importing MODE environment generated variables"
        source /tmp/.container/toi_restic/CONTAINER_MODE
    else
        mkdir -p /tmp/.container/toi_restic/
        modes=$(echo "${MODE}" | tr "," "\n")
        for mode in $modes ; do
            case "${mode,,}" in
                "backup" )
                    print_debug "Enabling Container Mode for: BACKUP"
                    echo "ENABLE_BACKUP=TRUE" >> /tmp/.container/toi_restic/CONTAINER_MODE
                ;;
                "check" )
                    print_debug "Enabling Container Mode for: CHECK"
                    echo "ENABLE_CHECK=TRUE" >> /tmp/.container/toi_restic/CONTAINER_MODE
                ;;
                "cleanup" )
                    print_debug "Enabling Container Mode for: CLEANUP"
                    echo "ENABLE_CLEANUP=TRUE" >> /tmp/.container/toi_restic/CONTAINER_MODE
                ;;
                "prune" )
                    print_debug "Enabling Container Mode for: PRUNE"
                    echo "ENABLE_PRUNE=TRUE" >> /tmp/.container/toi_restic/CONTAINER_MODE
                ;;
                "server" )
                    print_debug "Enabling Container Mode for: SERVER"
                    echo "ENABLE_SERVER=TRUE" >> /tmp/.container/toi_restic/CONTAINER_MODE
                ;;
                "standalone" | "manual" )
                    print_debug "Enabling Container Mode for: STANDALONE"
                    echo "ENABLE_STANDALONE=TRUE" >> /tmp/.container/toi_restic/CONTAINER_MODE
                ;;
                *)
                    print_error "Unknown 'MODE' environment variable - exitting.."
                    exit 1
                ;;
            esac
        done
        source /tmp/.container/toi_restic/CONTAINER_MODE
    fi
}

